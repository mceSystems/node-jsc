// Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#pragma once

#include "v8config.h"

// Taken from v8-version.h (this is important to nan, for example)
#define V8_MAJOR_VERSION 6
#define V8_MINOR_VERSION 2
#define V8_BUILD_NUMBER 414
#define V8_PATCH_LEVEL 50

/* (jscshim) When compiling jscshim, we'll include the JSC headers we need. Including these headers when 
 * compiling node is problematic:
 * - The main problem is class name collisions with WTF ("Web Template Framework"), which adds every class 
 *   to the global namespace ("using WTF::*" at the end of each file). Removing these "using" statements 
 *   broke JSC headers.
 * - Incuding JSCJSValue.h and JSCJSValueInlines.h includes a few other JSC/WTF headers, increasing 
 *   compilation time (and possibly size).
 *
 * Since we only need a few types, we'll solve this issue in two ways:
 * - For all types other then JSC::JSValue, we either just need a forward declaration, or 
 *   just need to know their size. To use these types, we'll use "place holders" generated by the 
 *	 OpaqueClassGenerator, which are basically types containing an unused array with the original class' 
 *   size. This might seem hacky, and it is. But, it let's us avoid heap allocations (pimpl), make GC 
 *   handling easier (Webkit's GC scans the stack), and Webkit's build process already uses a few scripts
 *   with similar ideas (which actually "inspired" our solution) for generating the interperter code 
 *   (see Webkit's "offlineasm").
 * - For JSC::JSValue, the above solution is not enough: JSC::JSValues are used by v8::Local instances,
 *   which are used pretty much everywhere when using v8. Thus, we'd prefer to avoid calling into
 *   node every time we use a Local, and keep it a header only class. Since a JSValue is just a 
 *   64-bit value, and we only need a couple of it's methods, I've creates a tiny version of
 *   of JSCJSValue which is compatible "complete" type. This is hacky, but the basic implementation
 *   of JSCJSValue is unlikely to change in the near future. Refer to v8::Local class documentation
 *   for more information. */
#ifdef BUILDING_JSCSHIM
	#include "jsc/config.h"

	#include <JavaScriptCore/JSCJSValue.h>
	#include <JavaScriptCore/ThrowScope.h>
	#include <JavaScriptCore/PropertyDescriptor.h>
#else
	#include "jsc-types.h"
#endif

namespace JSC {
	// ExecState is not a "normal" class, but actaully an array of Registers, so we won't put it in jsc-types.h
	class ExecState;
}

#include <stdint.h>
#include <utility>
#include <memory>

#ifdef V8_OS_WIN

// Setup for Windows DLL export/import. When building the V8 DLL the
// BUILDING_V8_SHARED needs to be defined. When building a program which uses
// the V8 DLL USING_V8_SHARED needs to be defined. When either building the V8
// static library or building a program which uses the V8 static library neither
// BUILDING_V8_SHARED nor USING_V8_SHARED should be defined.
#ifdef BUILDING_V8_SHARED
# define V8_EXPORT __declspec(dllexport)
#elif USING_V8_SHARED
# define V8_EXPORT __declspec(dllimport)
#else
# define V8_EXPORT
#endif  // BUILDING_V8_SHARED

#else  // V8_OS_WIN

// Setup for Linux shared library export.
#if V8_HAS_ATTRIBUTE_VISIBILITY
# ifdef BUILDING_V8_SHARED
#  define V8_EXPORT __attribute__ ((visibility("default")))
# else
#  define V8_EXPORT
# endif
#else
# define V8_EXPORT
#endif

#endif // V8_OS_WIN

#define TYPE_CHECK(T, S)                                       \
  while (false) {                                              \
    *(static_cast<T* volatile*>(0)) = static_cast<S*>(0);      \
  }

#ifdef V8_ENABLE_CHECKS
	#define CheckCast(value)
#endif

namespace v8
{
class AccessorSignature;
class Array;
class ArrayBuffer;
class Boolean;
class BooleanObject;
class Context;
class CpuProfiler;
class Data;
class DataView;
class Date;
class EscapableHandleScope;
template <class T> class Eternal;
class Exception;
class ExtensionConfiguration;
class External;
class ExternalOneByteStringResource;
class ExternalStringResourceBase;
class Float32Array;
class Float64Array;
class Function;
template <typename T> class FunctionCallbackInfo;
class FunctionTemplate;
template <class F> class Global;
class HandleScope;
class HeapProfiler;
class HeapStatistics;
class Int32;
class Int8Array;
class Int16Array;
class Int32Array;
class Integer;
class Isolate;
class JSON;
template <class T> class Local;
class Location;
class Locker;
class Map;
template <class T> class Maybe;
template <class T> class MaybeLocal;
class Message;
class Module;
class Name;
template<class T> class NonCopyablePersistentTraits;
class Number;
class NumberObject;
class Object;
class ObjectTemplate;
template <class T, class M = NonCopyablePersistentTraits<T> > class Persistent;
template <class T> class PersistentBase;
class Platform;
class Primitive;
class Private;
class Promise;
class PromiseRejectMessage;
class PropertyDescriptor;
template <typename T> class PropertyCallbackInfo;
class Proxy;
class RegExp;
class RetainedObjectInfo;
template <typename T> class ReturnValue;
class Script;
class ScriptCompiler;
class Set;
class SharedArrayBuffer;
class Signature;
class String;
class StringObject;
class StackFrame;
class StackTrace;
class Symbol;
class Template;
class TypedArray;
class Uint8Array;
class Uint8ClampedArray;
class Uint16Array;
class Uint32;
class Uint32Array;
class UnboundScript;
class Utils;
class V8;
class Value;
class ValueDeserializer;
class ValueSerializer;
template <typename T> class WeakCallbackInfo;

namespace jscshim
{
	// Forward declarations of jscshim's "shim" classes
	class APIAccessor;
	class Function;
	class GlobalObject;
	template <typename CallbackTypes> struct InterceptorInfo;
	class Isolate;
	class Message;
	class ObjectWithInterceptors;
	class Template;

	Local<Context> GetV8ContextForObject(JSC::JSObject * obj);
	Local<Name> JscPropertyNameToV8Name(JSC::ExecState * exec, const JSC::PropertyName& propertyName);

	// Expose JSC heap functionality
	class V8_EXPORT Heap
	{
	public:
		static void CollectGarbage(v8::Isolate * isolate);
		static void ProtectValue(const JSC::JSValue& value);
		static void UnprotectValue(const JSC::JSValue& value);
	};
}

V8_EXPORT Local<Primitive> Undefined(Isolate* isolate);
V8_EXPORT Local<Primitive> Null(Isolate* isolate);
V8_EXPORT Local<Boolean> True(Isolate* isolate);
V8_EXPORT Local<Boolean> False(Isolate* isolate);

/* (jscshim) In JSC, values are represented by a 64-bit JSC::JSValues, which may be a primitive value, 
 * or a pointer to a heap object (JSCell). 
 * See JSC's JSValue.h and http://phrack.org/papers/attacking_javascript_engines.html for a 
 * detailed explanation. 
 * JSC's GC scans the native stack, so as long as Local instanecs are on the stack (we'll make sure
 * of that by deleting the "new" operator), we don't need to do anything special beside storing
 * the JSCValue itself. See https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/
 * for more information about WebKit's latest GC.
 * A few notes:
 * - Since JSValues are always 64-bit, we can't just store "T *" like v8 does, and we
 *   can't simply cast JSCValues to "T *" in the "->" and "*" operators. In these cases,
 *   we'll return a pointer to our JSValue (which is valid as long as our instance is valid).
 *   This might be a bit confusing internally for classes which represents heap objects, 
 *	 as the pointer we're returning is actually a pointer to the JSValue, which itself is a pointer
 *   to the actual heap object.
 * - JSC's API uses a type called "JSValueRef" to encapsulate JSCValues. The downside of 
 *   their API is that on 32-bit platforms, in order to wrap "primitive" values (non-heap values),
 *   values are wrapped with heap wrapper objects, which we'll prefer to avoid. 
 *
 * TODO: Should we store (and pass around) JSC::EncodedValue, rather then JSValue? */
template <class T>
class Local
{
private:
	friend class AccessorSignature;
	friend class jscshim::APIAccessor;
	friend class Array;
	friend class ArrayBuffer;
	friend class ArrayBufferView;
	friend class BooleanObject;
	friend class Context;
	friend class DataView;
	friend class Date;
	template <class F> friend class Eternal;
	friend class Exception;
	friend class External;
	friend class Function;
	friend class jscshim::Function;
	template <typename F> friend class FunctionCallbackInfo;
	friend class FunctionTemplate;
	friend Local<Context> jscshim::GetV8ContextForObject(JSC::JSObject * obj);
	template <class F> friend class Global;
	friend class jscshim::GlobalObject;
	friend class Integer;
	template <typename CallbackTypes> friend struct jscshim::InterceptorInfo;
	friend class Isolate;
	friend class jscshim::Isolate;
	friend Local<Name> jscshim::JscPropertyNameToV8Name(JSC::ExecState * exec, const JSC::PropertyName& propertyName);
	friend class JSON;
	template <class F> friend class Local;
	friend class Map;
	template <class F> friend class MaybeLocal;
	friend class Message;
	friend class Number;
	friend class NumberObject;
	friend class Object;
	friend class ObjectTemplate;
	friend class jscshim::ObjectWithInterceptors;
	template <class F, class M> friend class Persistent;
	template <class F> friend class PersistentBase;
	friend class Private;
	friend class Promise;
	friend class PropertyDescriptor;
	friend class Proxy;
	friend class RegExp;
	template <class F> friend class ReturnValue;
	friend class Script;
	friend class ScriptCompiler;
	friend class Set;
	friend class SharedArrayBuffer;
	friend class Signature;
	friend class StackFrame;
	friend class StackTrace;
	friend class String;
	friend class StringObject;
	friend class Symbol;
	friend class SymbolObject;
	friend class Template;
	friend class jscshim::Template;
	friend class TryCatch;
	friend class Utils;
	friend class UnboundScript;
	friend class Value;
	
	friend class Uint8Array;
	friend class Uint8ClampedArray;
	friend class Int8Array;
	friend class Uint16Array;
	friend class Int16Array;
	friend class Int32Array;
	friend class Uint32Array;
	friend class Float32Array;
	friend class Float64Array;

	friend Local<Primitive> Undefined(Isolate* isolate);
	friend Local<Primitive> Null(Isolate* isolate);
	friend Local<Boolean> True(Isolate* isolate);
	friend Local<Boolean> False(Isolate* isolate);

	JSC::JSValue val_;

public:
	V8_INLINE Local() : val_() {}

	V8_INLINE Local(const Local<T>& that) :
		val_(that.val_)
	{
	}

	template <class S>
	V8_INLINE Local(const Local<S>& that) : 
		val_(that.val_)
	{
		TYPE_CHECK(T, S);
	}

	/* (jscshim) Make sure we clear the value, since th GC scans the stack,
	 * and might see our value even after our destructor will be called. 
	 * It's not something we really need to worry about, we're just helping the 
	 * GC in situations where our destructor has been called but some stack space
	 * was reserved (and not initialized) before the GC was called. 
	 * TODO: Is it really necessary? */
	V8_INLINE ~Local()
	{
		Clear();
	}

	V8_INLINE Local<T>& operator=(const Local<T>& rhs)
	{
		val_ = rhs.val_;
		return *this;
	}

	V8_INLINE bool IsEmpty() const { return val_.isEmpty(); }

	V8_INLINE void Clear() { val_ = JSC::JSValue(); }

	V8_INLINE T* operator->() const { return reinterpret_cast<T *>(const_cast<JSC::JSValue *>(&val_)); }

	V8_INLINE T* operator*() const { return reinterpret_cast<T *>(const_cast<JSC::JSValue *>(&val_)); }

	template <class S>
	V8_INLINE bool operator==(const Local<S>& that) const
	{
		return val_ == that.val_;
	}

	template <class S>
	V8_INLINE bool operator==(const PersistentBase<S>& that) const {
		return val_ == that.val_;
	}

	template <class S>
	V8_INLINE bool operator!=(const Local<S>& that) const
	{
		return !operator==(that);
	}

	template <class S>
	V8_INLINE bool operator!=(const PersistentBase<S>& that) const {
		return !operator==(that);
	}

	template <class S>
	V8_INLINE static Local<T> Cast(Local<S> that)
	{
		return Local<T>::New(T::Cast(*that));
	}

	template <class S>
	V8_INLINE Local<S> As() const 
	{
		return Local<S>::Cast(*this);
	}

	V8_INLINE static Local<T> New(Isolate* isolate, Local<T> that);
	V8_INLINE static Local<T> New(Isolate* isolate, const PersistentBase<T>& that);

	// (jscshim) Disallow dynmically allocated instances, since we count on JSC GC stack scanning
	void * operator new(size_t size) = delete;
	void * operator new[](size_t size) = delete;
	void operator delete(void *, size_t) = delete;
	void operator delete[](void *, size_t) = delete;

private:
	explicit V8_INLINE Local(const JSC::JSValue& that) : val_(that) {}

	V8_INLINE static Local<T> New(T* that);
	V8_INLINE static Local<T> New(const JSC::JSValue& that);
};

template <class T>
class MaybeLocal 
{
private:
	template <class F> friend class MaybeLocal;
	friend class Function;
	friend class Object;

	JSC::JSValue val_;

public:
	V8_INLINE MaybeLocal() {}

	template <class S>
	V8_INLINE MaybeLocal(const Local<S>& that) :
		val_(that.val_)
	{
		TYPE_CHECK(T, S);
	}

	V8_INLINE MaybeLocal(const MaybeLocal<T>& that) :
		val_(that.val_)
	{
	}

	V8_INLINE MaybeLocal<T>& operator=(const MaybeLocal<T>& rhs)
	{
		val_ = rhs.val_;
		return *this;
	}

	/* (jscshim) Make sure we clear the pointer to our value from the stack, since th GC scans the stack,
	 * and might see our pointer even after our destructor will be called. */
	V8_INLINE ~MaybeLocal()
	{
		val_ = JSC::JSValue();
	}

	V8_INLINE bool IsEmpty() const { return val_.isEmpty(); }

	template <class S>
	V8_WARN_UNUSED_RESULT V8_INLINE bool ToLocal(Local<S>* out) const
	{
		out->val_ = val_;
		return !IsEmpty();
	}

	V8_INLINE Local<T> ToLocalChecked();

	template <class S>
	V8_INLINE Local<S> FromMaybe(Local<S> default_value) const
	{
		return IsEmpty() ? default_value : Local<S>::New(val_);
	}

private:
	// jscshim: Unsafe, as there is no TYPE_CHECK here. Use with care.
	template <class S>
	V8_INLINE MaybeLocal(const MaybeLocal<S>& that) :
		val_(that.val_)
	{
	}
};

template <class T>
class Eternal
{
public:
	V8_INLINE Eternal() { }

	template <class S>
	V8_INLINE Eternal(Isolate* isolate, Local<S> handle)
	{
		Set(isolate, handle);
	}

	V8_INLINE Local<T> Get(Isolate* isolate) { return Local<T>(val_); }

	V8_INLINE bool IsEmpty() const { return val_.isEmpty(); }

	template<class S>
	V8_INLINE void Set(Isolate* isolate, Local<S> handle)
	{
		val_ = handle.val_;
		jscshim::Heap::ProtectValue(val_);
	}

private:
	JSC::JSValue val_;
};

typedef void (*FatalErrorCallback)(const char* location, const char* message);

typedef void (*MessageCallback)(Local<Message> message, Local<Value> data);

class V8_EXPORT Exception
{
public:
	static Local<Value> RangeError(Local<String> message);
	static Local<Value> ReferenceError(Local<String> message);
	static Local<Value> SyntaxError(Local<String> message);
	static Local<Value> TypeError(Local<String> message);
	static Local<Value> Error(Local<String> message);

	static Local<Message> CreateMessage(Isolate* isolate, Local<Value> exception);

	static Local<StackTrace> GetStackTrace(Local<Value> exception);
};

typedef int* (*CounterLookupCallback)(const char* name);

typedef void* (*CreateHistogramCallback)(const char* name,
                                         int min,
                                         int max,
                                         size_t buckets);

typedef void (*AddHistogramSampleCallback)(void* histogram, int sample);

class ScriptOriginOptions {
public:
	V8_INLINE ScriptOriginOptions(bool is_shared_cross_origin = false,
		bool is_opaque = false, bool is_wasm = false,
		bool is_module = false)
		: flags_((is_shared_cross_origin ? kIsSharedCrossOrigin : 0) |
				 (is_wasm ? kIsWasm : 0) | (is_opaque ? kIsOpaque : 0) |
				 (is_module ? kIsModule : 0)) {}
	V8_INLINE ScriptOriginOptions(int flags)
		: flags_(flags &
				 (kIsSharedCrossOrigin | kIsOpaque | kIsWasm | kIsModule)) {}

	bool IsSharedCrossOrigin() const {
		return (flags_ & kIsSharedCrossOrigin) != 0;
	}
	bool IsOpaque() const { return (flags_ & kIsOpaque) != 0; }
	bool IsWasm() const { return (flags_ & kIsWasm) != 0; }
	bool IsModule() const { return (flags_ & kIsModule) != 0; }

	int Flags() const { return flags_; }

private:
	enum {
		kIsSharedCrossOrigin = 1,
		kIsOpaque = 1 << 1,
		kIsWasm = 1 << 2,
		kIsModule = 1 << 3
	};
	const int flags_;
};

class ScriptOrigin
{
public:
	V8_INLINE ScriptOrigin(
		Local<Value> resource_name,
		Local<Integer> resource_line_offset = Local<Integer>(),
		Local<Integer> resource_column_offset = Local<Integer>(),
		Local<Boolean> resource_is_shared_cross_origin = Local<Boolean>(),
		Local<Integer> script_id = Local<Integer>(),
		Local<Value> source_map_url = Local<Value>(),
		Local<Boolean> resource_is_opaque = Local<Boolean>(),
		Local<Boolean> is_wasm = Local<Boolean>(),
		Local<Boolean> is_module = Local<Boolean>());

	V8_INLINE Local<Value> ResourceName() const { return resource_name_; }
	V8_INLINE Local<Integer> ResourceLineOffset() const { return resource_line_offset_; }
	V8_INLINE Local<Integer> ResourceColumnOffset() const { return resource_column_offset_; }
	V8_INLINE Local<Integer> ScriptID() const { return script_id_; }
	V8_INLINE Local<Value> SourceMapUrl() const { return source_map_url_; }
	V8_INLINE ScriptOriginOptions Options() const { return options_; }

private:
	Local<Value> resource_name_;
	Local<Integer> resource_line_offset_;
	Local<Integer> resource_column_offset_;
	ScriptOriginOptions options_;
	Local<Integer> script_id_;
	Local<Value> source_map_url_;
};

class V8_EXPORT Message
{
public:
	Local<String> Get() const;

	V8_DEPRECATE_SOON("Use maybe version", Local<String> GetSourceLine() const);
	V8_WARN_UNUSED_RESULT MaybeLocal<String> GetSourceLine(Local<Context> context) const;

	ScriptOrigin GetScriptOrigin() const;

	Local<Value> GetScriptResourceName() const;

	Local<StackTrace> GetStackTrace() const;

	V8_DEPRECATE_SOON("Use maybe version", int GetLineNumber() const);
	V8_WARN_UNUSED_RESULT Maybe<int> GetLineNumber(Local<Context> context) const;

	int GetStartPosition() const;
	int GetEndPosition() const;

	V8_DEPRECATE_SOON("Use maybe version", int GetStartColumn() const);
	V8_WARN_UNUSED_RESULT Maybe<int> GetStartColumn(Local<Context> context) const;

	V8_DEPRECATED("Use maybe version", int GetEndColumn() const);
	V8_WARN_UNUSED_RESULT Maybe<int> GetEndColumn(Local<Context> context) const;

	static const int kNoLineNumberInfo = 0;
	static const int kNoColumnInfo = 0;
	static const int kNoScriptIdInfo = 0;
};

class V8_EXPORT TryCatch
{
public:
	TryCatch(Isolate* isolate);
	~TryCatch();

	bool HasCaught() const { return !!exception_; }

	bool CanContinue() const;

	bool HasTerminated() const;

	Local<Value> ReThrow();

	Local<Value> Exception() const;

	V8_WARN_UNUSED_RESULT MaybeLocal<Value> StackTrace(Local<Context> context) const;

	Local<v8::Message> Message() const;

	void Reset();

	void SetVerbose(bool value) { is_verbose_ = true; }

	bool IsVerbose() const { return is_verbose_; }

	void SetCaptureMessage(bool value);

	TryCatch(const TryCatch&) = delete;
	void operator=(const TryCatch&) = delete;

	// TryCatch objects must be stack allocated, so prevent dynamic allocation
	void * operator new(size_t size) = delete;
	void * operator new[](size_t size) = delete;
	void operator delete(void *, size_t) = delete;
	void operator delete[](void *, size_t) = delete;

private:
	jscshim::Isolate * isolate_;
	TryCatch* next_;
	void * exception_;
	unsigned int shim_scopes_current_depth_;
	jscshim::Message * message_obj_;
	bool is_verbose_ : 1;
	bool capture_message_ : 1;
	bool rethrow_ : 1;

	friend class jscshim::Isolate;
};

class V8_EXPORT StackTrace
{
public:
	enum StackTraceOptions 
	{
		kLineNumber = 1,
		kColumnOffset = 1 << 1 | kLineNumber,
		kScriptName = 1 << 2,
		kFunctionName = 1 << 3,
		kIsEval = 1 << 4,
		kIsConstructor = 1 << 5,
		kScriptNameOrSourceURL = 1 << 6,
		kScriptId = 1 << 7,
		kExposeFramesAcrossSecurityOrigins = 1 << 8,
		kOverview = kLineNumber | kColumnOffset | kScriptName | kFunctionName,
		kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
	};

	Local<StackFrame> GetFrame(uint32_t index) const;

	int GetFrameCount() const;

	static Local<StackTrace> CurrentStackTrace(
		Isolate* isolate,
		int frame_limit,
		StackTraceOptions options = kOverview);
};

class V8_EXPORT StackFrame
{
public:
	int GetLineNumber() const;

	int GetColumn() const;

	int GetScriptId() const;

	Local<String> GetScriptName() const;

	Local<String> GetFunctionName() const;

	bool IsEval() const;

	bool IsConstructor() const;
};

enum GCType {
	kGCTypeScavenge = 1 << 0,
	kGCTypeMarkSweepCompact = 1 << 1,
	kGCTypeIncrementalMarking = 1 << 2,
	kGCTypeProcessWeakCallbacks = 1 << 3,
	kGCTypeAll = kGCTypeScavenge | kGCTypeMarkSweepCompact |
	kGCTypeIncrementalMarking | kGCTypeProcessWeakCallbacks
};

enum GCCallbackFlags {
	kNoGCCallbackFlags = 0,
	kGCCallbackFlagConstructRetainedObjectInfos = 1 << 1,
	kGCCallbackFlagForced = 1 << 2,
	kGCCallbackFlagSynchronousPhantomCallbackProcessing = 1 << 3,
	kGCCallbackFlagCollectAllAvailableGarbage = 1 << 4,
	kGCCallbackFlagCollectAllExternalMemory = 1 << 5,
	kGCCallbackScheduleIdleGarbageCollection = 1 << 6,
};

typedef void (*InterruptCallback)(Isolate* isolate, void* data);

class V8_EXPORT HeapStatistics
{
private:
	size_t total_heap_size_;
	size_t total_heap_size_executable_;
	size_t total_physical_size_;
	size_t total_available_size_;
	size_t used_heap_size_;
	size_t heap_size_limit_;
	size_t malloced_memory_;
	size_t peak_malloced_memory_;
	bool does_zap_garbage_;

public:
	HeapStatistics() :
		total_heap_size_(0),
		total_heap_size_executable_(0),
		total_physical_size_(0),
		total_available_size_(0),
		used_heap_size_(0),
		heap_size_limit_(0),
		malloced_memory_(0),
		peak_malloced_memory_(0),
		does_zap_garbage_(false)
	{
		// TODO: IMPLEMENT
	}

	size_t total_heap_size() { return total_heap_size_; }
	size_t total_heap_size_executable() { return total_heap_size_executable_; }
	size_t total_physical_size() { return total_physical_size_; }
	size_t total_available_size() { return total_available_size_; }
	size_t used_heap_size() { return used_heap_size_; }
	size_t heap_size_limit() { return heap_size_limit_; }
	size_t malloced_memory() { return malloced_memory_; }
	size_t peak_malloced_memory() { return peak_malloced_memory_; }
	size_t does_zap_garbage() { return does_zap_garbage_; }
};

class V8_EXPORT HeapSpaceStatistics
{
private:
	const char* space_name_;
	size_t space_size_;
	size_t space_used_size_;
	size_t space_available_size_;
	size_t physical_space_size_;

public:
	HeapSpaceStatistics() : 
		space_name_(0), 
		space_used_size_(0), 
		space_available_size_(0), 
		physical_space_size_(0)
	{
		// TODO: IMPLEMENT
	}

	const char* space_name() { return space_name_; }
	size_t space_size() { return space_size_; }
	size_t space_used_size() { return space_used_size_; }
	size_t space_available_size() { return space_available_size_; }
	size_t physical_space_size() { return physical_space_size_; }
};

enum class MemoryPressureLevel { kNone, kModerate, kCritical };

class V8_EXPORT ExtensionConfiguration
{
public:
	ExtensionConfiguration(int name_count, const char* names[]) { }
};

class V8_EXPORT Context
{
public:
	Local<Object> Global();

	static Local<Context> New(
		Isolate* isolate, ExtensionConfiguration* extensions = NULL,
		MaybeLocal<ObjectTemplate> global_template = MaybeLocal<ObjectTemplate>(),
		MaybeLocal<Value> global_object = MaybeLocal<Value>());

	Isolate* GetIsolate();

	void SetSecurityToken(Local<Value> token);

	Local<Value> GetSecurityToken();

	void Enter();

	void Exit();

	Local<Value> GetEmbedderData(int index);

	void SetEmbedderData(int index, Local<Value> value);

	void * GetAlignedPointerFromEmbedderData(int index);

	void SetAlignedPointerInEmbedderData(int index, void* value);

	class Scope 
	{
	private:
		Local<Context> m_context;

	public:
		explicit V8_INLINE Scope(Local<Context> context) : 
			m_context(context)
		{
			m_context->Enter();
		}

		V8_INLINE ~Scope() { m_context->Exit();  }
	};
};

class V8_EXPORT HandleScope
{
public:
	explicit HandleScope(Isolate* isolate) {};

	V8_INLINE static int NumberOfHandles(Isolate* isolate)
	{
		// TODO
		return 0;
	}

	HandleScope(const HandleScope&) = delete;
	void operator=(const HandleScope&) = delete;
};

class V8_EXPORT EscapableHandleScope : public HandleScope
{
public:
	explicit EscapableHandleScope(Isolate* isolate) : HandleScope(isolate)
	{
	}

	template <class T>
	V8_INLINE Local<T> Escape(Local<T> value)
	{
		return value;
	}
};

using SealHandleScope = HandleScope;

class V8_EXPORT Locker
{
public:
	explicit Locker(Isolate* isolate)
	{
		// TODO: IMPLEMENT
	}

	~Locker()
	{
		// TODO: IMPLEMENT
	}

	static bool IsActive()
	{
		// TODO: IMPLEMENT
		return false;
	}

	// Disallow copying and assigning.
	Locker(const Locker&) = delete;
	void operator=(const Locker&) = delete;
};

class V8_EXPORT Data 
{
private:
	Data();
};

class V8_EXPORT Location {
 public:
  int GetLineNumber() { return line_number_; }
  int GetColumnNumber() { return column_number_; }

  Location(int line_number, int column_number)
      : line_number_(line_number), column_number_(column_number) {}

 private:
  int line_number_;
  int column_number_;
};

class V8_EXPORT Module {
 public:
  enum Status {
    kUninstantiated,
    kInstantiating,
    kInstantiated,
    kEvaluating,
    kEvaluated,
    kErrored
  };

  Status GetStatus() const;

  Local<Value> GetException() const;

  int GetModuleRequestsLength() const;

  Local<String> GetModuleRequest(int i) const;

  Location GetModuleRequestLocation(int i) const;

  int GetIdentityHash() const;

  typedef MaybeLocal<Module> (*ResolveCallback)(Local<Context> context,
                                                Local<String> specifier,
                                                Local<Module> referrer);

  V8_DEPRECATED("Use Maybe<bool> version",
                bool Instantiate(Local<Context> context,
                                 ResolveCallback callback));
  V8_WARN_UNUSED_RESULT Maybe<bool> InstantiateModule(Local<Context> context,
                                                      ResolveCallback callback);

  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Evaluate(Local<Context> context);

  Local<Value> GetModuleNamespace();
};

class V8_EXPORT ScriptCompiler
{
public:
	// (jscshim) TODO: Not implemented
	struct V8_EXPORT CachedData
	{
		enum BufferPolicy 
		{
			BufferNotOwned,
			BufferOwned
		};

		CachedData(const uint8_t* data, int length,
				   BufferPolicy buffer_policy = BufferNotOwned)
		{
		}

		const uint8_t* data;
		int length;
		bool rejected;
	};

	class Source
	{
	public:
		V8_INLINE Source(Local<String> source_string, const ScriptOrigin& origin,
			CachedData* cached_data = NULL);
		V8_INLINE Source(Local<String> source_string,
						 CachedData* cached_data = NULL);

		// (jscshim) TODO: Implement?
		const CachedData* GetCachedData() const { return nullptr; }

		Source& operator=(const Source&) = delete;

	private:
		friend class ScriptCompiler;
		friend class UnboundScript;

		explicit Source(const Source&);
		
		Local<String> source_string;

		// Origin information
		Local<Value> resource_name;
		Local<Integer> resource_line_offset;
		Local<Integer> resource_column_offset;
		Local<Value> source_map_url;
	};

	enum CompileOptions
	{
		kNoCompileOptions = 0,
		kProduceParserCache,
		kConsumeParserCache,
		kProduceCodeCache,
		kConsumeCodeCache
	};

	static V8_WARN_UNUSED_RESULT MaybeLocal<UnboundScript> CompileUnboundScript(
		Isolate* isolate, Source* source,
		CompileOptions options = kNoCompileOptions);

	static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(
		Local<Context> context, Source* source,
		CompileOptions options = kNoCompileOptions);

	static uint32_t CachedDataVersionTag();

	static V8_WARN_UNUSED_RESULT MaybeLocal<Module> CompileModule(
		Isolate* isolate, Source* source);
};

class V8_EXPORT UnboundScript
{
public:
	Local<Script> BindToCurrentContext();
};

class V8_EXPORT Script
{
public:
	static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(
		Local<Context> context, Local<String> source,
		ScriptOrigin* origin = nullptr);

	V8_DEPRECATE_SOON("Use maybe version", Local<Value> Run());
	V8_WARN_UNUSED_RESULT MaybeLocal<Value> Run(Local<Context> context);
};

class V8_EXPORT Private : public Data
{
public:
	Local<Value> Name() const;

	static Local<Private> New(Isolate* isolate,
							  Local<String> name = Local<String>());

	static Local<Private> ForApi(Isolate* isolate, Local<String> name);
};

class V8_EXPORT Value : public Data
{
public:
	bool IsUndefined() const;

	bool IsNull() const;

	bool IsNullOrUndefined() const;

	bool IsTrue() const;

	bool IsFalse() const;

	bool IsName() const;

	bool IsString() const;

	bool IsSymbol() const;
	
	bool IsFunction() const;

	bool IsArray() const;

	bool IsObject() const;

	bool IsBoolean() const;

	bool IsNumber() const;

	bool IsExternal() const;

	bool IsInt32() const;

	bool IsUint32() const;

	bool IsDate() const;

	bool IsArgumentsObject() const;

	bool IsBooleanObject() const;

	bool IsNumberObject() const;

	bool IsStringObject() const;

	bool IsSymbolObject() const;

	bool IsArrayBuffer() const;

	bool IsArrayBufferView() const;

	bool IsTypedArray() const;

	bool IsUint8Array() const;

	bool IsUint8ClampedArray() const;

	bool IsInt8Array() const;

	bool IsUint16Array() const;

	bool IsInt16Array() const;

	bool IsUint32Array() const;

	bool IsInt32Array() const;

	bool IsFloat32Array() const;

	bool IsFloat64Array() const;

	bool IsDataView() const;

	bool IsSharedArrayBuffer() const;

	bool IsNativeError() const;

	bool IsRegExp() const;

	bool IsAsyncFunction() const;

	bool IsGeneratorFunction() const;

	bool IsGeneratorObject() const;

	bool IsPromise() const;

	bool IsMap() const;

	bool IsSet() const;

	bool IsSetIterator() const;

	bool IsMapIterator() const;

	bool IsWeakMap() const;

	bool IsWeakSet() const;

	bool IsProxy() const;

	V8_WARN_UNUSED_RESULT MaybeLocal<Uint32> ToArrayIndex(Local<Context> context) const;

	V8_WARN_UNUSED_RESULT Maybe<bool> BooleanValue(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT Maybe<double> NumberValue(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT Maybe<int64_t> IntegerValue(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT Maybe<uint32_t> Uint32Value(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT Maybe<int32_t> Int32Value(Local<Context> context) const;

	V8_DEPRECATE_SOON("Use maybe version", V8_INLINE bool BooleanValue() const);
	V8_DEPRECATE_SOON("Use maybe version", double NumberValue() const);
	V8_DEPRECATE_SOON("Use maybe version", V8_INLINE int64_t IntegerValue() const);
	V8_DEPRECATE_SOON("Use maybe version", V8_INLINE uint32_t Uint32Value() const);
	V8_DEPRECATE_SOON("Use maybe version", V8_INLINE int32_t Int32Value() const);

	V8_WARN_UNUSED_RESULT MaybeLocal<Boolean> ToBoolean(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT MaybeLocal<Number> ToNumber(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT MaybeLocal<String> ToString(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT MaybeLocal<String> ToDetailString(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT MaybeLocal<Object> ToObject(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT MaybeLocal<Integer> ToInteger(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT MaybeLocal<Uint32> ToUint32(Local<Context> context) const;
	V8_WARN_UNUSED_RESULT MaybeLocal<Int32> ToInt32(Local<Context> context) const;

	V8_DEPRECATE_SOON("Use maybe version",
					  Local<Boolean> ToBoolean(Isolate* isolate) const);
	V8_DEPRECATE_SOON("Use maybe version",
					  Local<Number> ToNumber(Isolate* isolate) const);
	V8_DEPRECATE_SOON("Use maybe version",
					  Local<String> ToString(Isolate* isolate) const);
	V8_DEPRECATED("Use maybe version",
				  Local<String> ToDetailString(Isolate* isolate) const);
	V8_DEPRECATE_SOON("Use maybe version",
					  Local<Object> ToObject(Isolate* isolate) const);
	V8_DEPRECATE_SOON("Use maybe version",
					  Local<Integer> ToInteger(Isolate* isolate) const);
	V8_DEPRECATED("Use maybe version",
					  Local<Uint32> ToUint32(Isolate* isolate) const);
	V8_DEPRECATE_SOON("Use maybe version",
					  Local<Int32> ToInt32(Isolate* isolate) const);

	inline V8_DEPRECATE_SOON("Use maybe version", Local<String> ToString() const);

	V8_DEPRECATE_SOON("Use maybe version", bool Equals(Local<Value> that) const);
	V8_WARN_UNUSED_RESULT Maybe<bool> Equals(Local<Context> context, Local<Value> that) const;
	bool StrictEquals(Local<Value> that) const;
	bool SameValue(Local<Value> that) const;

	template <class T> V8_INLINE static Value* Cast(T* value);

	Local<String> TypeOf(Isolate*);

	Maybe<bool> InstanceOf(Local<Context> context, Local<Object> object);
};

class V8_EXPORT External : public Value
{
public:
	static Local<External> New(Isolate* isolate, void* value);
	V8_INLINE static External* Cast(v8::Value * obj);
	void* Value() const;

private:
	friend class Value;};

class V8_EXPORT Primitive : public Value { };

class V8_EXPORT Boolean : public Primitive
{
public:
	bool Value() const;
	V8_INLINE static Boolean* Cast(v8::Value* obj);
	V8_INLINE static Local<Boolean> New(Isolate* isolate, bool value);
};

class V8_EXPORT Number : public Primitive
{
public:
	double Value() const;
	V8_INLINE static Number* Cast(v8::Value* obj);
	static Local<Number> New(Isolate* isolate, double value);
};

class V8_EXPORT Integer : public Number
{
public:
	static Local<Integer> New(Isolate* isolate, int32_t value);

	static Local<Integer> NewFromUnsigned(Isolate* isolate, uint32_t value);

	V8_INLINE static Integer* Cast(v8::Value* obj);
};

class V8_EXPORT Int32 : public Integer
{
public:
	V8_INLINE static Int32* Cast(v8::Value* obj);
};

class V8_EXPORT Uint32 : public Integer
{
public:
	V8_INLINE static Uint32* Cast(v8::Value* obj);
};

class V8_EXPORT Name : public Primitive
{
public:
	V8_INLINE static Name* Cast(v8::Value* obj);
};

class V8_EXPORT Symbol : public Name
{
public:
	Local<Value> Name() const;

	static Local<Symbol> New(Isolate* isolate,
                             Local<String> name = Local<String>());

	static Local<Symbol> For(Isolate *isolate, Local<String> name);

	static Local<Symbol> ForApi(Isolate *isolate, Local<String> name);

	static Local<Symbol> GetHasInstance(Isolate* isolate);
	static Local<Symbol> GetIsConcatSpreadable(Isolate* isolate);
	static Local<Symbol> GetIterator(Isolate* isolate);
	static Local<Symbol> GetMatch(Isolate* isolate);
	static Local<Symbol> GetReplace(Isolate* isolate);
	static Local<Symbol> GetSearch(Isolate* isolate);
	static Local<Symbol> GetSplit(Isolate* isolate);
	static Local<Symbol> GetToPrimitive(Isolate* isolate);
	static Local<Symbol> GetToStringTag(Isolate* isolate);
	static Local<Symbol> GetUnscopables(Isolate* isolate);

	V8_INLINE static Symbol* Cast(Value* obj);
};

enum class NewStringType { kNormal, kInternalized };

class V8_EXPORT String : public Name
{
public:
	static const int kMaxLength = (1 << 28) - 16;

	enum Encoding {
		UNKNOWN_ENCODING = 0x1,
		TWO_BYTE_ENCODING = 0x0,
		ONE_BYTE_ENCODING = 0x8
	};

	int Length() const;

	int Utf8Length() const;

	bool IsOneByte() const;

	static Local<String> Empty(Isolate* isolate);

	enum WriteOptions
	{
		NO_OPTIONS = 0,
		HINT_MANY_WRITES_EXPECTED = 1,
		NO_NULL_TERMINATION = 2,
		PRESERVE_ONE_BYTE_NULL = 4,
		
		REPLACE_INVALID_UTF8 = 8
	};

	int Write(uint16_t* buffer,
			  int start = 0,
			  int length = -1,
			  int options = NO_OPTIONS) const;

	int WriteOneByte(uint8_t* buffer,
					 int start = 0,
					 int length = -1,
					 int options = NO_OPTIONS) const;

	int WriteUtf8(char* buffer,
				  int length = -1,
				  int* nchars_ref = NULL,
				  int options = NO_OPTIONS) const;

	bool IsExternal() const;

	bool IsExternalOneByte() const;

	class V8_EXPORT ExternalStringResourceBase
	{
	public:
		virtual ~ExternalStringResourceBase() {}

		virtual void Dispose() { delete this; }
	};

	class V8_EXPORT ExternalStringResource : public ExternalStringResourceBase {
	public:
		virtual ~ExternalStringResource() {}

		virtual const uint16_t* data() const = 0;

		virtual size_t length() const = 0;

	protected:
		ExternalStringResource() {}
	};

	class V8_EXPORT ExternalOneByteStringResource : public ExternalStringResourceBase
	{
	public:
		virtual ~ExternalOneByteStringResource() {}

		virtual const char* data() const = 0;

		virtual size_t length() const = 0;
	};

	ExternalStringResourceBase* GetExternalStringResourceBase(Encoding* encoding_out) const;

	ExternalStringResource* GetExternalStringResource() const;

	const ExternalOneByteStringResource* GetExternalOneByteStringResource() const;

	V8_INLINE static String* Cast(v8::Value* obj);

	enum NewStringType 
	{
		kNormalString = static_cast<int>(v8::NewStringType::kNormal),
		kInternalizedString = static_cast<int>(v8::NewStringType::kInternalized)
	};

	static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromOneByte(
      Isolate* isolate, const uint8_t* data, v8::NewStringType type,
      int length = -1);

	static V8_DEPRECATE_SOON(
		"Use maybe version",
		Local<String> NewFromTwoByte(Isolate* isolate, const uint16_t* data,
			NewStringType type = kNormalString,
			int length = -1));

	static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromTwoByte(
		Isolate* isolate, const uint16_t* data, v8::NewStringType type,
		int length = -1);

	static V8_DEPRECATE_SOON(
		"Use maybe version",
		Local<String> NewFromUtf8(Isolate* isolate, const char* data,
			NewStringType type = kNormalString,
			int length = -1));

	static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromUtf8(
		Isolate* isolate, const char* data, v8::NewStringType type,
		int length = -1);

	static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewExternalOneByte(
		Isolate* isolate, ExternalOneByteStringResource* resource);

	static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewExternalTwoByte(
		Isolate* isolate, ExternalStringResource* resource);

	static Local<String> Concat(Local<String> left, Local<String> right);

	class V8_EXPORT Utf8Value 
	{
	public:
		V8_DEPRECATE_SOON("Use Isolate version",
						  explicit Utf8Value(Local<v8::Value> obj));
		Utf8Value(Isolate* isolate, Local<v8::Value> obj);
		~Utf8Value();
		char* operator*() { return str_; }
		const char* operator*() const { return str_; }
		int length() const { return length_; }

		// Disallow copying and assigning.
		Utf8Value(const Utf8Value&) = delete;
		void operator=(const Utf8Value&) = delete;

	private:
		char* str_;
		int length_;
	};

	class V8_EXPORT Value
	{
	public:
		explicit Value(Local<v8::Value> obj);
		~Value();
		uint16_t* operator*() { return str_; }
		const uint16_t* operator*() const { return str_; }
		int length() const { return length_; }

		// Disallow copying and assigning.
		Value(const Value&) = delete;
		void operator=(const Value&) = delete;

	private:
		uint16_t* str_;
		int length_;
	};
};

typedef void(*GenericNamedPropertyGetterCallback)(
	Local<Name> property, const PropertyCallbackInfo<Value>& info);

typedef void(*GenericNamedPropertySetterCallback)(
	Local<Name> property, Local<Value> value,
	const PropertyCallbackInfo<Value>& info);

typedef void(*GenericNamedPropertyQueryCallback)(
	Local<Name> property, const PropertyCallbackInfo<Integer>& info);

typedef void(*GenericNamedPropertyDeleterCallback)(
	Local<Name> property, const PropertyCallbackInfo<Boolean>& info);

typedef void(*GenericNamedPropertyEnumeratorCallback)(
	const PropertyCallbackInfo<Array>& info);

typedef void(*GenericNamedPropertyDescriptorCallback)(
	Local<Name> property, const PropertyCallbackInfo<Value>& info);

typedef void(*GenericNamedPropertyDefinerCallback)(
	Local<Name> property, const PropertyDescriptor& desc,
	const PropertyCallbackInfo<Value>& info);


typedef void (*IndexedPropertyGetterCallback)(
    uint32_t index,
    const PropertyCallbackInfo<Value>& info);

typedef void (*IndexedPropertySetterCallback)(
    uint32_t index,
    Local<Value> value,
    const PropertyCallbackInfo<Value>& info);

typedef void (*IndexedPropertyQueryCallback)(
    uint32_t index,
    const PropertyCallbackInfo<Integer>& info);

typedef void (*IndexedPropertyDeleterCallback)(
    uint32_t index,
    const PropertyCallbackInfo<Boolean>& info);

typedef void (*IndexedPropertyEnumeratorCallback)(
    const PropertyCallbackInfo<Array>& info);

typedef void (*IndexedPropertyDefinerCallback)(
    uint32_t index, const PropertyDescriptor& desc,
    const PropertyCallbackInfo<Value>& info);

typedef void (*IndexedPropertyDescriptorCallback)(
    uint32_t index, const PropertyCallbackInfo<Value>& info);


enum class PropertyHandlerFlags {
	kNone = 0,

	kAllCanRead = 1,

	kNonMasking = 1 << 1,

	kOnlyInterceptStrings = 1 << 2,
};

struct NamedPropertyHandlerConfiguration
{
	NamedPropertyHandlerConfiguration(
		/** Note: getter is required */
		GenericNamedPropertyGetterCallback getter = 0,
		GenericNamedPropertySetterCallback setter = 0,
		GenericNamedPropertyQueryCallback query = 0,
		GenericNamedPropertyDeleterCallback deleter = 0,
		GenericNamedPropertyEnumeratorCallback enumerator = 0,
		Local<Value> data = Local<Value>(),
		PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
		: getter(getter),
		setter(setter),
		query(query),
		deleter(deleter),
		enumerator(enumerator),
		definer(0),
		descriptor(0),
		data(data),
		flags(flags) {}

	NamedPropertyHandlerConfiguration(
		GenericNamedPropertyGetterCallback getter,
		GenericNamedPropertySetterCallback setter,
		GenericNamedPropertyDescriptorCallback descriptor,
		GenericNamedPropertyDeleterCallback deleter,
		GenericNamedPropertyEnumeratorCallback enumerator,
		GenericNamedPropertyDefinerCallback definer,
		Local<Value> data = Local<Value>(),
		PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
		: getter(getter),
		setter(setter),
		query(0),
		deleter(deleter),
		enumerator(enumerator),
		definer(definer),
		descriptor(descriptor),
		data(data),
		flags(flags) {}

	GenericNamedPropertyGetterCallback getter;
	GenericNamedPropertySetterCallback setter;
	GenericNamedPropertyQueryCallback query;
	GenericNamedPropertyDeleterCallback deleter;
	GenericNamedPropertyEnumeratorCallback enumerator;
	GenericNamedPropertyDefinerCallback definer;
	GenericNamedPropertyDescriptorCallback descriptor;
	Local<Value> data;
	PropertyHandlerFlags flags;
};

struct IndexedPropertyHandlerConfiguration {
  IndexedPropertyHandlerConfiguration(
      /** Note: getter is required */
      IndexedPropertyGetterCallback getter = 0,
      IndexedPropertySetterCallback setter = 0,
      IndexedPropertyQueryCallback query = 0,
      IndexedPropertyDeleterCallback deleter = 0,
      IndexedPropertyEnumeratorCallback enumerator = 0,
      Local<Value> data = Local<Value>(),
      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
      : getter(getter),
        setter(setter),
        query(query),
        deleter(deleter),
        enumerator(enumerator),
        definer(0),
        descriptor(0),
        data(data),
        flags(flags) {}

  IndexedPropertyHandlerConfiguration(
      IndexedPropertyGetterCallback getter,
      IndexedPropertySetterCallback setter,
      IndexedPropertyDescriptorCallback descriptor,
      IndexedPropertyDeleterCallback deleter,
      IndexedPropertyEnumeratorCallback enumerator,
      IndexedPropertyDefinerCallback definer,
      Local<Value> data = Local<Value>(),
      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
      : getter(getter),
        setter(setter),
        query(0),
        deleter(deleter),
        enumerator(enumerator),
        definer(definer),
        descriptor(descriptor),
        data(data),
        flags(flags) {}

  IndexedPropertyGetterCallback getter;
  IndexedPropertySetterCallback setter;
  IndexedPropertyQueryCallback query;
  IndexedPropertyDeleterCallback deleter;
  IndexedPropertyEnumeratorCallback enumerator;
  IndexedPropertyDefinerCallback definer;
  IndexedPropertyDescriptorCallback descriptor;
  Local<Value> data;
  PropertyHandlerFlags flags;
};

enum PropertyAttribute
{
	None = 0,
	ReadOnly = 1 << 0,
	DontEnum = 1 << 1,
	DontDelete = 1 << 2
};

typedef void (*AccessorGetterCallback)(
	Local<String> property,
	const PropertyCallbackInfo<Value>& info);
typedef void (*AccessorNameGetterCallback)(
	Local<Name> property,
	const PropertyCallbackInfo<Value>& info);

typedef void (*AccessorSetterCallback)(
	Local<String> property,
	Local<Value> value,
	const PropertyCallbackInfo<void>& info);
typedef void (*AccessorNameSetterCallback)(
	Local<Name> property,
	Local<Value> value,
	const PropertyCallbackInfo<void>& info);

enum AccessControl
{
	DEFAULT = 0,
	ALL_CAN_READ = 1,
	ALL_CAN_WRITE = 1 << 1,
	PROHIBITS_OVERWRITING = 1 << 2
};

enum PropertyFilter {
	ALL_PROPERTIES = 0,
	ONLY_WRITABLE = 1,
	ONLY_ENUMERABLE = 2,
	ONLY_CONFIGURABLE = 4,
	SKIP_STRINGS = 8,
	SKIP_SYMBOLS = 16
};

enum class KeyCollectionMode { kOwnOnly, kIncludePrototypes };

enum class IndexFilter { kIncludeIndices, kSkipIndices };

enum class IntegrityLevel { kFrozen, kSealed };

class V8_EXPORT Object : public Value
{
public:
	V8_DEPRECATE_SOON("Use maybe version",
					  bool Set(Local<Value> key, Local<Value> value));
	V8_WARN_UNUSED_RESULT Maybe<bool> Set(Local<Context> context,
										  Local<Value> key, Local<Value> value);

	V8_DEPRECATE_SOON("Use maybe version",
					  bool Set(uint32_t index, Local<Value> value));
	V8_WARN_UNUSED_RESULT Maybe<bool> Set(Local<Context> context, uint32_t index,
										  Local<Value> value);

	V8_WARN_UNUSED_RESULT Maybe<bool> CreateDataProperty(Local<Context> context,
														Local<Name> key,
														Local<Value> value);
	V8_WARN_UNUSED_RESULT Maybe<bool> CreateDataProperty(Local<Context> context,
														uint32_t index,
														Local<Value> value);

	V8_WARN_UNUSED_RESULT Maybe<bool> DefineOwnProperty(
		Local<Context> context, Local<Name> key, Local<Value> value,
		PropertyAttribute attributes = None);

	V8_WARN_UNUSED_RESULT Maybe<bool> DefineProperty(
		Local<Context> context, Local<Name> key, PropertyDescriptor& descriptor);

	V8_DEPRECATED("Use CreateDataProperty / DefineOwnProperty",
				  Maybe<bool> ForceSet(Local<Context> context, Local<Value> key,
									   Local<Value> value,
									   PropertyAttribute attribs = None));

	V8_DEPRECATE_SOON("Use maybe version", Local<Value> Get(Local<Value> key));
	V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,
												Local<Value> key);

	V8_DEPRECATE_SOON("Use maybe version", Local<Value> Get(uint32_t index));
	V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,
												uint32_t index);

	V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetPropertyAttributes(
		Local<Context> context, Local<Value> key);

	V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetOwnPropertyDescriptor(Local<Context> context,
		Local<Name> key);

	V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context, Local<Value> key);
	V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context, uint32_t index);

	Maybe<bool> Delete(Local<Context> context, Local<Value> key);
	V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context, uint32_t index);

	Maybe<bool> SetAccessor(Local<Context> context, Local<Name> name,
							AccessorNameGetterCallback getter,
							AccessorNameSetterCallback setter = 0,
							MaybeLocal<Value> data = MaybeLocal<Value>(),
							AccessControl settings = DEFAULT,
							PropertyAttribute attribute = None);

	V8_WARN_UNUSED_RESULT Maybe<bool> SetNativeDataProperty(
		Local<Context> context, Local<Name> name,
		AccessorNameGetterCallback getter,
		AccessorNameSetterCallback setter = nullptr,
		Local<Value> data = Local<Value>(), PropertyAttribute attributes = None);

	Maybe<bool> HasPrivate(Local<Context> context, Local<Private> key);
	Maybe<bool> DeletePrivate(Local<Context> context, Local<Private> key);
	Maybe<bool> SetPrivate(Local<Context> context, Local<Private> key,
						   Local<Value> value);
	MaybeLocal<Value> GetPrivate(Local<Context> context, Local<Private> key);

	V8_DEPRECATE_SOON("Use maybe version", Local<Array> GetPropertyNames());
	V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetPropertyNames(Local<Context> context);
	V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetPropertyNames(
		Local<Context> context, KeyCollectionMode mode,
		PropertyFilter property_filter, IndexFilter index_filter);

	V8_DEPRECATE_SOON("Use maybe version", Local<Array> GetOwnPropertyNames());
	V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetOwnPropertyNames(Local<Context> context);

	V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetOwnPropertyNames(
		Local<Context> context, PropertyFilter filter);

	Local<Value> GetPrototype();

	V8_WARN_UNUSED_RESULT Maybe<bool> SetPrototype(Local<Context> context,
												   Local<Value> prototype);

	V8_WARN_UNUSED_RESULT MaybeLocal<String> ObjectProtoToString(Local<Context> context);

	Local<String> GetConstructorName();

	Maybe<bool> SetIntegrityLevel(Local<Context> context, IntegrityLevel level);

	int InternalFieldCount();
	V8_INLINE static int InternalFieldCount(const PersistentBase<Object>& object);

	Local<Value> GetInternalField(int index);

	void SetInternalField(int index, Local<Value> value);

	void * GetAlignedPointerFromInternalField(int index);
	V8_INLINE static void* GetAlignedPointerFromInternalField(const PersistentBase<Object>& object, int index);

	void SetAlignedPointerInInternalField(int index, void* value);
	void SetAlignedPointerInInternalFields(int argc, int indices[], void* values[]);

	V8_WARN_UNUSED_RESULT Maybe<bool> HasOwnProperty(Local<Context> context,
													 Local<Name> key);
	V8_WARN_UNUSED_RESULT Maybe<bool> HasOwnProperty(Local<Context> context,
													 uint32_t index);

	V8_WARN_UNUSED_RESULT Maybe<bool> HasRealNamedProperty(Local<Context> context, Local<Name> key);
	V8_WARN_UNUSED_RESULT Maybe<bool> HasRealIndexedProperty(Local<Context> context, uint32_t index);
	V8_WARN_UNUSED_RESULT Maybe<bool> HasRealNamedCallbackProperty(Local<Context> context, Local<Name> key);

	V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedPropertyInPrototypeChain(
		Local<Context> context, Local<Name> key);

	V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedProperty(
		Local<Context> context, Local<Name> key);

	V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetRealNamedPropertyAttributes(
		Local<Context> context, Local<Name> key);

	Local<Object> Clone();

	Local<Context> CreationContext();

	bool IsCallable();

	bool IsConstructor();

	V8_WARN_UNUSED_RESULT MaybeLocal<Value> CallAsFunction(Local<Context> context,
														   Local<Value> recv,
														   int argc,
														   Local<Value> argv[]);

	V8_WARN_UNUSED_RESULT MaybeLocal<Value> CallAsConstructor(
		Local<Context> context, int argc, Local<Value> argv[]);

	V8_DEPRECATE_SOON("Keep track of isolate correctly", Isolate* GetIsolate());

	static Local<Object> New(Isolate* isolate);

	V8_INLINE static Object* Cast(Value* obj);
};

enum class PromiseHookType { kInit, kResolve, kBefore, kAfter };

typedef void(*PromiseHook)(PromiseHookType type, Local<Promise> promise, Local<Value> parent);

enum PromiseRejectEvent
{
	kPromiseRejectWithNoHandler = 0,
	kPromiseHandlerAddedAfterReject = 1
};

class PromiseRejectMessage {
public:
	PromiseRejectMessage(Local<Promise> promise, PromiseRejectEvent event,
						 Local<Value> value, Local<StackTrace> stack_trace)
		: promise_(promise),
		  event_(event),
		  value_(value) {}

	V8_INLINE Local<Promise> GetPromise() const { return promise_; }
	V8_INLINE PromiseRejectEvent GetEvent() const { return event_; }
	V8_INLINE Local<Value> GetValue() const { return value_; }

	V8_DEPRECATED("Use v8::Exception::CreateMessage(GetValue())->GetStackTrace()",
		V8_INLINE Local<StackTrace> GetStackTrace() const) {
		return Local<StackTrace>();
	}

private:
	Local<Promise> promise_;
	PromiseRejectEvent event_;
	Local<Value> value_;
};

typedef void(*PromiseRejectCallback)(PromiseRejectMessage message);

class V8_EXPORT Promise : public Object
{
public:
	enum PromiseState { kPending, kFulfilled, kRejected };

	class V8_EXPORT Resolver : public Object 
	{
	public:
		 static V8_WARN_UNUSED_RESULT MaybeLocal<Resolver> New(Local<Context> context);

		 Local<Promise> GetPromise();

		 Maybe<bool> Resolve(Local<Context> context, Local<Value> value);

		 Maybe<bool> Reject(Local<Context> context, Local<Value> value);

		 V8_INLINE static Resolver* Cast(Value* obj);
	};

	V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Catch(Local<Context> context,
													Local<Function> handler);

	V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Then(Local<Context> context,
												   Local<Function> handler);

	bool HasHandler();

	Local<Value> Result();

	PromiseState State();

	V8_INLINE static Promise* Cast(Value* obj);
};

enum class MicrotasksPolicy { kExplicit, kScoped, kAuto };

class V8_EXPORT Array : public Object
{
public:
	uint32_t Length() const;

	static Local<Array> New(Isolate* isolate, int length = 0);

	V8_INLINE static Array* Cast(Value* obj);
};

class V8_EXPORT Map : public Object
{
public:
	size_t Size() const;
	void Clear();
	V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,
												Local<Value> key);
	V8_WARN_UNUSED_RESULT MaybeLocal<Map> Set(Local<Context> context,
											  Local<Value> key,
											  Local<Value> value);
	V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,
										  Local<Value> key);
	V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,
											 Local<Value> key);

	/**
	* Returns an array of length Size() * 2, where index N is the Nth key and
	* index N + 1 is the Nth value.
	*/
	Local<Array> AsArray() const;

	static Local<Map> New(Isolate* isolate);

	V8_INLINE static Map* Cast(Value* obj);

private:
	Map();
};

class V8_EXPORT Set : public Object
{
public:
	size_t Size() const;
	void Clear();
	V8_WARN_UNUSED_RESULT MaybeLocal<Set> Add(Local<Context> context,
											  Local<Value> key);
	V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,
										  Local<Value> key);
	V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,
											 Local<Value> key);

	Local<Array> AsArray() const;

	static Local<Set> New(Isolate* isolate);

	V8_INLINE static Set* Cast(Value* obj);

private:
	Set();
};

class V8_EXPORT ArrayBufferView : public Object
{
public:
	Local<ArrayBuffer> Buffer();

	size_t ByteOffset();

	size_t ByteLength();

	V8_INLINE static ArrayBufferView* Cast(Value* obj);
};

class V8_EXPORT TypedArray : public ArrayBufferView
{
public:
	size_t Length();

	V8_INLINE static TypedArray* Cast(Value* obj);
};

class V8_EXPORT Uint8Array : public TypedArray
{
public:
	static Local<Uint8Array> New(Local<ArrayBuffer> array_buffer,
								 size_t byte_offset, size_t length);
	static Local<Uint8Array> New(Local<SharedArrayBuffer> array_buffer,
								 size_t byte_offset, size_t length);

	V8_INLINE static Uint8Array* Cast(Value* obj);
};

class V8_EXPORT Uint8ClampedArray : public TypedArray
{
public:
	static Local<Uint8ClampedArray> New(Local<ArrayBuffer> array_buffer,
										size_t byte_offset, size_t length);
	static Local<Uint8ClampedArray> New(Local<SharedArrayBuffer> array_buffer,
										size_t byte_offset, size_t length);

	V8_INLINE static Uint8ClampedArray* Cast(Value* obj);
};

class V8_EXPORT Int8Array : public TypedArray
{
public:
	static Local<Int8Array> New(Local<ArrayBuffer> array_buffer,
								size_t byte_offset, size_t length);
	static Local<Int8Array> New(Local<SharedArrayBuffer> array_buffer,
								size_t byte_offset, size_t length);

	V8_INLINE static Int8Array* Cast(Value* obj);
};

class V8_EXPORT Uint16Array : public TypedArray
{
public:
	static Local<Uint16Array> New(Local<ArrayBuffer> array_buffer,
								  size_t byte_offset, size_t length);
	static Local<Uint16Array> New(Local<SharedArrayBuffer> array_buffer,
								  size_t byte_offset, size_t length);

	V8_INLINE static Uint16Array* Cast(Value* obj);
};

class V8_EXPORT Int16Array : public TypedArray
{
public:
	static Local<Int16Array> New(Local<ArrayBuffer> array_buffer,
								 size_t byte_offset, size_t length);
	static Local<Int16Array> New(Local<SharedArrayBuffer> array_buffer,
								 size_t byte_offset, size_t length);

	V8_INLINE static Int16Array* Cast(Value* obj);
};

class V8_EXPORT Int32Array : public TypedArray
{
public:
	static Local<Int32Array> New(Local<ArrayBuffer> array_buffer,
								 size_t byte_offset, size_t length);
	static Local<Int32Array> New(Local<SharedArrayBuffer> array_buffer,
								 size_t byte_offset, size_t length);

	V8_INLINE static Int32Array* Cast(Value* obj);
};

class V8_EXPORT Uint32Array : public TypedArray
{
public:
	static Local<Uint32Array> New(Local<ArrayBuffer> array_buffer,
								  size_t byte_offset, size_t length);
	static Local<Uint32Array> New(Local<SharedArrayBuffer> array_buffer,
								  size_t byte_offset, size_t length);

	V8_INLINE static Uint32Array* Cast(Value* obj);
};

class V8_EXPORT Float32Array : public TypedArray
{
public:
	static Local<Float32Array> New(Local<ArrayBuffer> array_buffer,
								   size_t byte_offset, size_t length);
	static Local<Float32Array> New(Local<SharedArrayBuffer> array_buffer,
								   size_t byte_offset, size_t length);

	V8_INLINE static Float32Array* Cast(Value* obj);
};

class V8_EXPORT Float64Array : public TypedArray
{
public:
	static Local<Float64Array> New(Local<ArrayBuffer> array_buffer,
								   size_t byte_offset, size_t length);
	static Local<Float64Array> New(Local<SharedArrayBuffer> array_buffer,
								   size_t byte_offset, size_t length);

	V8_INLINE static Float64Array* Cast(Value* obj);
};

class V8_EXPORT DataView : public ArrayBufferView {
public:
	static Local<DataView> New(Local<ArrayBuffer> array_buffer,
							   size_t byte_offset, size_t length);
	static Local<DataView> New(Local<SharedArrayBuffer> shared_array_buffer,
							   size_t byte_offset, size_t length);
	V8_INLINE static DataView* Cast(Value* obj);

private:
	DataView();
};

class V8_EXPORT Date : public Object
{
public:
	static V8_WARN_UNUSED_RESULT MaybeLocal<Value> New(Local<Context> context, double time);

	double ValueOf() const;

	V8_INLINE static Date* Cast(Value* obj);
};

class V8_EXPORT NumberObject : public Object
{
public:
	static Local<Value> New(Isolate* isolate, double value);

	double ValueOf() const;

	V8_INLINE static NumberObject* Cast(Value* obj);
};

class V8_EXPORT BooleanObject : public Object
{
public:
	static Local<Value> New(Isolate* isolate, bool value);
	V8_DEPRECATED("Pass an isolate", static Local<Value> New(bool value));

	bool ValueOf() const;

	V8_INLINE static BooleanObject* Cast(Value* obj);
};

class V8_EXPORT StringObject : public Object {
public:
	static Local<Value> New(Local<String> value);

	Local<String> ValueOf() const;

	V8_INLINE static StringObject* Cast(Value* obj);
};

class V8_EXPORT SymbolObject : public Object {
public:
	static Local<Value> New(Isolate* isolate, Local<Symbol> value);

	Local<Symbol> ValueOf() const;

	V8_INLINE static SymbolObject* Cast(Value* obj);
};

class V8_EXPORT RegExp : public Object {
public:
	enum Flags {
		kNone = 0,
		kGlobal = 1 << 0,
		kIgnoreCase = 1 << 1,
		kMultiline = 1 << 2,
		kSticky = 1 << 3,
		kUnicode = 1 << 4,
		kDotAll = 1 << 5,
	};

	static V8_DEPRECATE_SOON("Use maybe version",
							 Local<RegExp> New(Local<String> pattern, Flags flags));
	static V8_WARN_UNUSED_RESULT MaybeLocal<RegExp> New(Local<Context> context,
														Local<String> pattern,
														Flags flags);

	Local<String> GetSource() const;

	Flags GetFlags() const;

	V8_INLINE static RegExp* Cast(Value* obj);
};

class V8_EXPORT JSON {
 public:
  static V8_WARN_UNUSED_RESULT MaybeLocal<Value> Parse(
      Local<Context> context, Local<String> json_string);

  static V8_WARN_UNUSED_RESULT MaybeLocal<String> Stringify(
      Local<Context> context, Local<Object> json_object,
      Local<String> gap = Local<String>());
};

class V8_EXPORT ValueSerializer
{
public:
	class V8_EXPORT Delegate
	{
	public:
		virtual ~Delegate() {}

		virtual void ThrowDataCloneError(Local<String> message) = 0;

		virtual Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object);

		virtual Maybe<uint32_t> GetSharedArrayBufferId(
			Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer);
	};

	explicit ValueSerializer(Isolate* isolate);
	ValueSerializer(Isolate* isolate, Delegate* delegate);
	~ValueSerializer();

	void WriteHeader();

	V8_WARN_UNUSED_RESULT Maybe<bool> WriteValue(Local<Context> context,
												 Local<Value> value);

	V8_WARN_UNUSED_RESULT std::pair<uint8_t*, size_t> Release();

	void TransferArrayBuffer(uint32_t transfer_id,
							 Local<ArrayBuffer> array_buffer);

	void SetTreatArrayBufferViewsAsHostObjects(bool mode);

	void WriteUint32(uint32_t value);
	void WriteUint64(uint64_t value);
	void WriteDouble(double value);
	void WriteRawBytes(const void* source, size_t length);
};

class V8_EXPORT ValueDeserializer
{
public:
	class V8_EXPORT Delegate
	{
	public:
		virtual ~Delegate() {}

		virtual MaybeLocal<Object> ReadHostObject(Isolate* isolate);
	};

	ValueDeserializer(Isolate* isolate, const uint8_t* data, size_t size, Delegate* delegate);
	~ValueDeserializer();

	V8_WARN_UNUSED_RESULT Maybe<bool> ReadHeader(Local<Context> context);

	V8_WARN_UNUSED_RESULT MaybeLocal<Value> ReadValue(Local<Context> context);

	void TransferArrayBuffer(uint32_t transfer_id,
							 Local<ArrayBuffer> array_buffer);

	void TransferSharedArrayBuffer(uint32_t id,
								   Local<SharedArrayBuffer> shared_array_buffer);

	uint32_t GetWireFormatVersion() const;

	V8_WARN_UNUSED_RESULT bool ReadUint32(uint32_t* value);
	V8_WARN_UNUSED_RESULT bool ReadUint64(uint64_t* value);
	V8_WARN_UNUSED_RESULT bool ReadDouble(double* value);
	V8_WARN_UNUSED_RESULT bool ReadRawBytes(size_t length, const void** data);
};

// (jscshim) Note: We currently count on PropertyDescriptor to be stack allocated, in order to avoid calls to JSC's gcProtect\gcUnprotect
class V8_EXPORT PropertyDescriptor
{
public:
	// GenericDescriptor
	PropertyDescriptor();

	// DataDescriptor
	PropertyDescriptor(Local<Value> value);

	// DataDescriptor with writable property
	PropertyDescriptor(Local<Value> value, bool writable);

	// AccessorDescriptor
	PropertyDescriptor(Local<Value> get, Local<Value> set);

	~PropertyDescriptor();

	Local<Value> value() const;
	bool has_value() const;

	Local<Value> get() const;
	bool has_get() const;
	Local<Value> set() const;
	bool has_set() const;

	void set_enumerable(bool enumerable);
	bool enumerable() const;
	bool has_enumerable() const;

	void set_configurable(bool configurable);
	bool configurable() const;
	bool has_configurable() const;

	bool writable() const;
	bool has_writable() const;

	using PrivateData = JSC::PropertyDescriptor;
	PrivateData* get_private() const { return private_; }

	PropertyDescriptor(const PropertyDescriptor&) = delete;
	void operator=(const PropertyDescriptor&) = delete;

private:
	friend class jscshim::ObjectWithInterceptors;

	PrivateData* private_;
	bool isPrivateDataOwner_;

	explicit PropertyDescriptor(PrivateData * existingPrivateData);

	/* (jscshim) Store\copy the value\setter\getter on the stack when we own the underlying JSC descriptor,
	 * so JSC's GC will see them */
	JSC::JSValue value_;
	JSC::JSValue getter_;
	JSC::JSValue setter_;
};

class V8_EXPORT Proxy : public Object
{
public:
	Local<Object> GetTarget();
	Local<Value> GetHandler();
	bool IsRevoked();
	void Revoke();

	static MaybeLocal<Proxy> New(Local<Context> context,
								 Local<Object> local_target,
								 Local<Object> local_handler);

	V8_INLINE static Proxy* Cast(Value* obj);
};

template<typename T>
class PropertyCallbackInfo
{
public:
	V8_INLINE Isolate* GetIsolate() const;

	V8_INLINE Local<Value> Data() const;

	V8_INLINE Local<Object> This() const;

	V8_INLINE Local<Object> Holder() const;

	V8_INLINE ReturnValue<T> GetReturnValue() const;

	V8_INLINE bool ShouldThrowOnError() const;

private:
	friend class v8::jscshim::APIAccessor;
	friend class v8::jscshim::ObjectWithInterceptors;

	PropertyCallbackInfo(Local<Object>	 thisValue,
						 Local<Object>	 holder,
						 Local<Value>	 data,
						 Isolate		 * isolate,
						 JSC::JSValue	 * returnValue,
						 bool			 shouldThrowOnError);
	
	Local<Object> this_;
	Local<Value> data_;
	Local<Object> holder_;
	Isolate * isolate_;
	JSC::JSValue * returnValue_;
	bool shouldThrowOnError_;
};

typedef void (*FunctionCallback)(const FunctionCallbackInfo<Value>& info);

enum class ConstructorBehavior { kThrow, kAllow };

class V8_EXPORT Function : public Object
{
public:
	static MaybeLocal<Function> New(
		Local<Context> context, FunctionCallback callback,
		Local<Value> data = Local<Value>(), int length = 0,
		ConstructorBehavior behavior = ConstructorBehavior::kAllow);

	static V8_DEPRECATE_SOON(
		"Use maybe version",
		Local<Function> New(Isolate* isolate, FunctionCallback callback,
 							Local<Value> data = Local<Value>(), int length = 0));

	V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(
		Local<Context> context, int argc, Local<Value> argv[]) const;

	V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(Local<Context> context);

	V8_DEPRECATE_SOON("Use maybe version",
					  Local<Value> Call(Local<Value> recv, int argc,
										Local<Value> argv[]));
	V8_WARN_UNUSED_RESULT MaybeLocal<Value> Call(Local<Context> context,
												 Local<Value> recv, int argc,
												 Local<Value> argv[]);

	void SetName(Local<String> name);
	Local<Value> GetName() const;

	Local<Value> GetInferredName() const;

	Local<Value> GetDebugName() const;

	Local<Value> GetDisplayName() const;

	Local<Value> GetBoundFunction() const;

	V8_INLINE static Function* Cast(Value* obj);
};

class V8_EXPORT Template : public Data
{
public:
	void Set(Local<Name> name, Local<Data> value, PropertyAttribute attributes = None);
	V8_INLINE void Set(Isolate* isolate, const char* name, Local<Data> value);

	void SetAccessorProperty(
		Local<Name> name,
		Local<FunctionTemplate> getter = Local<FunctionTemplate>(),
		Local<FunctionTemplate> setter = Local<FunctionTemplate>(),
		PropertyAttribute attribute = None,
		AccessControl settings = DEFAULT);

	void SetNativeDataProperty(
		Local<String> name, AccessorGetterCallback getter,
		AccessorSetterCallback setter = 0,
		Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,
		Local<AccessorSignature> signature = Local<AccessorSignature>(),
		AccessControl settings = DEFAULT);
	void SetNativeDataProperty(
		Local<Name> name, AccessorNameGetterCallback getter,
		AccessorNameSetterCallback setter = 0,
		Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,
		Local<AccessorSignature> signature = Local<AccessorSignature>(),
		AccessControl settings = DEFAULT);
};

class V8_EXPORT ObjectTemplate : public Template
{
public:
	static Local<ObjectTemplate> New(
		Isolate * isolate,
		Local<FunctionTemplate> constructor = Local<FunctionTemplate>());

	V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(Local<Context> context);

	void SetAccessor(
		Local<String> name, AccessorGetterCallback getter,
		AccessorSetterCallback setter = 0, Local<Value> data = Local<Value>(),
		AccessControl settings = DEFAULT, PropertyAttribute attribute = None,
		Local<AccessorSignature> signature = Local<AccessorSignature>());
	void SetAccessor(
		Local<Name> name, AccessorNameGetterCallback getter,
		AccessorNameSetterCallback setter = 0, Local<Value> data = Local<Value>(),
		AccessControl settings = DEFAULT, PropertyAttribute attribute = None,
		Local<AccessorSignature> signature = Local<AccessorSignature>());

	void SetInternalFieldCount(int value);

	void SetHandler(const NamedPropertyHandlerConfiguration& configuration);
	void SetHandler(const IndexedPropertyHandlerConfiguration& configuration);

	void SetCallAsFunctionHandler(FunctionCallback callback, Local<Value> data = Local<Value>());
};

class V8_EXPORT FunctionTemplate : public Template
{
public:
	static Local<FunctionTemplate> New(
		Isolate* isolate, FunctionCallback callback = 0,
		Local<Value> data = Local<Value>(),
		Local<Signature> signature = Local<Signature>(), int length = 0/*
		ConstructorBehavior behavior = ConstructorBehavior::kAllow*/);

	V8_DEPRECATE_SOON("Use maybe version", Local<Function> GetFunction());
	V8_WARN_UNUSED_RESULT MaybeLocal<Function> GetFunction(Local<Context> context);

	void Inherit(Local<FunctionTemplate> parent);

	Local<ObjectTemplate> PrototypeTemplate();

	void SetPrototypeProviderTemplate(Local<FunctionTemplate> prototype_provider);

	void SetClassName(Local<String> name);

	void SetCallHandler(FunctionCallback callback, Local<Value> data = Local<Value>());

	void SetLength(int length);

	Local<ObjectTemplate> InstanceTemplate();

	void SetHiddenPrototype(bool value);

	void ReadOnlyPrototype();

	void RemovePrototype();

	bool HasInstance(Local<Value> object);
};

class V8_EXPORT Signature : public Data
{
public:
	static Local<Signature> New(
		Isolate* isolate,
		Local<FunctionTemplate> receiver = Local<FunctionTemplate>());

private:
	Signature();
};

enum class ArrayBufferCreationMode { kInternalized, kExternalized };

class V8_EXPORT ArrayBuffer : public Object
{
public:
	class V8_EXPORT Allocator
	{
	public:
		virtual ~Allocator() {}

		virtual void* Allocate(size_t length) = 0;

		virtual void* AllocateUninitialized(size_t length) = 0;

		virtual void Free(void* data, size_t length) = 0;

		enum class AllocationMode { kNormal, kReservation };

		static Allocator * NewDefaultAllocator() 
		{
			// TODO
			return nullptr;
		}
	};

	// (jscshim) TODO: Handle real allocation base\length
	class V8_EXPORT Contents {
	public:
		Contents()
			: data_(nullptr),
			byte_length_(0),
			allocation_base_(nullptr),
			allocation_length_(0),
			allocation_mode_(Allocator::AllocationMode::kNormal) {}

		void* AllocationBase() const { return allocation_base_; }
		size_t AllocationLength() const { return allocation_length_; }
		Allocator::AllocationMode AllocationMode() const {
			return allocation_mode_;
		}

		void* Data() const { return data_; }
		size_t ByteLength() const { return byte_length_; }

	private:
		void* data_;
		size_t byte_length_;
		void* allocation_base_;
		size_t allocation_length_;
		Allocator::AllocationMode allocation_mode_;

		Contents(void* data, size_t byte_length)
			: data_(data),
			byte_length_(byte_length), 
			allocation_base_(data),
			allocation_length_(byte_length),
			allocation_mode_(Allocator::AllocationMode::kNormal) {}

		friend class ArrayBuffer;
	};

	size_t ByteLength() const;

	static Local<ArrayBuffer> New(Isolate* isolate, size_t byte_length);

	static Local<ArrayBuffer> New(
		Isolate* isolate, void* data, size_t byte_length,
		ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);

	bool IsNeuterable() const;

	void Neuter();

	bool IsExternal() const;

	Contents Externalize();

	Contents GetContents();

	V8_INLINE static ArrayBuffer* Cast(Value* obj);
};

class V8_EXPORT SharedArrayBuffer : public Object
{
public:
	// (jscshim) TODO: Handle real allocation base\length
	class V8_EXPORT Contents {  // NOLINT
	public:
		Contents()
			: data_(nullptr),
			byte_length_(0),
			allocation_base_(nullptr),
			allocation_length_(0),
			allocation_mode_(ArrayBuffer::Allocator::AllocationMode::kNormal) {}

		void* AllocationBase() const { return allocation_base_; }
		size_t AllocationLength() const { return allocation_length_; }
		ArrayBuffer::Allocator::AllocationMode AllocationMode() const {
			return allocation_mode_;
		}

		void* Data() const { return data_; }
		size_t ByteLength() const { return byte_length_; }

	private:
		void* data_;
		size_t byte_length_;
		void* allocation_base_;
		size_t allocation_length_;
		ArrayBuffer::Allocator::AllocationMode allocation_mode_;

		Contents(void* data, size_t byte_length)
			: data_(data),
			byte_length_(byte_length),
			allocation_base_(data),
			allocation_length_(byte_length),
			allocation_mode_(ArrayBuffer::Allocator::AllocationMode::kNormal) {}

		friend class SharedArrayBuffer;
	};

	size_t ByteLength() const;
		
	static Local<SharedArrayBuffer> New(Isolate* isolate, size_t byte_length);

	static Local<SharedArrayBuffer> New(
		Isolate* isolate, void* data, size_t byte_length,
		ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);

	bool IsExternal() const;

	Contents Externalize();

	Contents GetContents();

	V8_INLINE static SharedArrayBuffer* Cast(Value* obj);
};

/* (jscshim) Regarding function argument access:
 * - In v8, the "[]" operator simply accesses the stack (through a local internal::Object** member).
 * - In JSC, accessing function arguments is done though the ExecState passed to functions,
 *   which provides inline functions for accessing arguments. 
 * - JSC::ExecState is not a "real" object - it actually points to an array of "Registers". 
 *   Each Register has the following internal represnetation (taken from JSC's Register.h):
 *		union {
 *          EncodedJSValue value;
 *          CallFrame* callFrame;
 *          CodeBlock* codeBlock;
 *          EncodedValueDescriptor encodedValue;
 *          double number;
 *          int64_t integer;
 *      } u;
 * - Function arguments are continuous in the Register array.
 *
 * So, we have a few possible ways to access the arguments from here:
 * - Include the necessary headers directly an use the ExecState passed to the calling function. 
 *   Refer to the comments at the top of this header regarding why this is problematic.
 * - Provide helper function\class exoported from jscshim (node's binary). The downside here is 
 *   having to make a call into node for every argument access.
 * - Copy the arguments part of the Registers array, like JSC's *Arguments classes (DirectArguments, etc.),
 *   into a new buffer and pass it here.
 * - Simply pass the argument count and a pointer to the first argument, and access it directly from here.
 *   Since we know we're accessing JSValues, and the size of a Register is 64bit (see the union above), we
 *   can treat the Register array as a JSValue array.
 *
 * The first approach would have been the best option, if we could easily include JSC's headers here (which we can't).
 * The last option is a more hacky\dirty version of the first approach, relying on the internal structure of ExecState\Register.
 * But, it seems that the basic idea and structure of the ExecState\Register should be stable, and changes to them will probably
 * require us to review the changes anyway. So for now, in order to avoid the overhead of the other options, we'll go with the last one. */
template<typename T>
class FunctionCallbackInfo
{
public:
	V8_INLINE int Length() const;

	V8_INLINE Local<Value> operator[](int i) const;

	V8_INLINE Local<Object> This() const;

	V8_INLINE Local<Object> Holder() const;

	V8_INLINE Local<Value> NewTarget() const;

	V8_INLINE bool IsConstructCall() const;

	V8_INLINE Local<Value> Data() const;

	V8_INLINE Isolate* GetIsolate() const;

	V8_INLINE ReturnValue<T> GetReturnValue() const;

private:
	friend class v8::jscshim::Template;

	explicit FunctionCallbackInfo(JSC::JSValue	* arguments, 
								  int			argumentsCount,
								  Local<Object>	thisValue,
								  Local<Object>	holder,
								  Local<Value>	newTarget,
								  bool			isConstructorCall,
								  Local<Value>	data,
								  Isolate		* isolate,
								  JSC::JSValue	* returnValue);

	JSC::JSValue * arguments_;
	int argumentsCount_;
	Local<Object> this_;
	Local<Object> holder_;
	Local<Value> newTarget_;
	bool isConstructorCall_;
	Local<Value> data_;
	Isolate * isolate_;
	JSC::JSValue * returnValue_;
};

template <typename T>
class ReturnValue
{
public:
	template <typename S>
	V8_INLINE V8_DEPRECATE_SOON("Use Global<> instead",
								void Set(const Persistent<S>& handle));

	template <typename S>
	V8_INLINE void Set(const Local<S> handle);

	V8_INLINE void Set(bool value);
	V8_INLINE void Set(double i);
	V8_INLINE void Set(int32_t i);
	V8_INLINE void Set(uint32_t i);

	V8_INLINE void SetNull();
	V8_INLINE void SetUndefined();

	V8_INLINE void SetEmptyString();

private:
	template <typename F> friend class FunctionCallbackInfo;
	template <typename F> friend class PropertyCallbackInfo;

	explicit ReturnValue(JSC::JSValue * value) : 
		value_(value)
	{
	}

	JSC::JSValue * value_;
};

static const int kInternalFieldsInWeakCallback = 2;
static const int kEmbedderFieldsInWeakCallback = 2;

template <typename T>
class WeakCallbackInfo
{
public:
	typedef void (*Callback)(const WeakCallbackInfo<T>& data);

	WeakCallbackInfo(Isolate* isolate, T* parameter,
		void* embedder_fields[kEmbedderFieldsInWeakCallback],
		Callback* callback) : isolate_(isolate), parameter_(parameter), callback_(callback) {
		for (int i = 0; i < kEmbedderFieldsInWeakCallback; ++i) {
			embedder_fields_[i] = embedder_fields[i];
		}
	}

	V8_INLINE Isolate* GetIsolate() const { return isolate_; }
	V8_INLINE T* GetParameter() const { return parameter_; }
	V8_INLINE void* GetInternalField(int index) const;

	void SetSecondPassCallback(Callback callback) const { *callback_ = callback; }

private:
	Isolate* isolate_;
	T* parameter_;
	Callback* callback_;
	void* embedder_fields_[kEmbedderFieldsInWeakCallback];
};

enum class WeakCallbackType { kParameter, kInternalFields, kFinalizer };

namespace jscshim
{
	class V8_EXPORT WeakWrapper
	{
	private:
		v8::Isolate * m_isolate;
		JSC::Weak<JSC::JSObject> m_weak;
		typename WeakCallbackInfo<void>::Callback m_callback;
		void * m_callbackParameter;
		WeakCallbackType m_type;

	public:
		WeakWrapper(v8::Isolate * isolate, const JSC::JSValue& value, WeakCallbackType type, typename WeakCallbackInfo<void>::Callback callback, void * callbackParameter);

		V8_INLINE v8::Isolate * Isolate() const { return m_isolate; }
		V8_INLINE const typename WeakCallbackInfo<void>::Callback& Callback() const { return m_callback; }
		V8_INLINE void * CallbackParameter() const { return m_callbackParameter; }
		V8_INLINE WeakCallbackType Type() const { return m_type; }
	};
}

// (jscshim) See "Local" class documentation regarding JSValue handling
template <class T> 
class PersistentBase
{
private:
	JSC::JSValue val_;
	jscshim::WeakWrapper * weakWrapper_;

public:
	V8_INLINE void Reset();

	template <class S>
	V8_INLINE void Reset(Isolate* isolate, const Local<S>& other);

	V8_INLINE bool IsEmpty() const { return val_.isEmpty(); }

	V8_INLINE Local<T> Get(Isolate* isolate) const {
		return Local<T>::New(val_);
	}

	template <class S>
	V8_INLINE bool operator==(const PersistentBase<S>& that) const {
		return val_ == that.val_;
	}

	template <class S>
	V8_INLINE bool operator==(const Local<S>& that) const {
		return val_ == that.val_;
	}

	template <class S>
	V8_INLINE bool operator!=(const PersistentBase<S>& that) const {
		return !operator==(that);
	}

	template <class S>
	V8_INLINE bool operator!=(const Local<S>& that) const {
		return !operator==(that);
	}

	template <typename P>
	V8_INLINE void SetWeak(P* parameter,
						   typename WeakCallbackInfo<P>::Callback callback,
						   WeakCallbackType type);

	template<typename P>
	V8_INLINE P* ClearWeak();

	V8_INLINE void ClearWeak() { ClearWeak<void>(); }

	V8_INLINE void MarkIndependent();

	V8_INLINE bool IsNearDeath() const;

	V8_INLINE bool IsWeak() const;

	V8_INLINE void SetWrapperClassId(uint16_t class_id);

	PersistentBase(const PersistentBase& other) = delete;
	void operator=(const PersistentBase&) = delete;

private:
	template <class F> friend class Local;
	template <class F1, class F2> friend class Persistent;
	template <class F> friend class Global;
	template <class F> friend class ReturnValue;

	explicit V8_INLINE PersistentBase(const JSC::JSValue& val) : 
		val_(val), 
		weakWrapper_(nullptr)
	{
		jscshim::Heap::ProtectValue(val);
	}

	explicit V8_INLINE PersistentBase() : weakWrapper_(nullptr) {}
};

template <class T>
class Global : public PersistentBase<T> {
public:
	V8_INLINE Global() : PersistentBase<T>(JSC::JSValue()) {}
	
	template <class S>
	V8_INLINE Global(Isolate* isolate, Local<S> that) : PersistentBase<T>(that.val_)
{
		TYPE_CHECK(T, S);
	}
	
	template <class S>
	V8_INLINE Global(Isolate* isolate, const PersistentBase<S>& that) : PersistentBase<T>(that.val_)
	{
		TYPE_CHECK(T, S);
	}
	
	V8_INLINE Global(Global&& other) : PersistentBase<T>(other.val_) {  // NOLINT
		this->weakWrapper_ = other.weakWrapper_;
		other.val_ = JSC::JSValue();
		other.weakWrapper_ = nullptr;
	}
	
	V8_INLINE ~Global() { this->Reset(); }
	
	template <class S>
	V8_INLINE Global& operator=(Global<S>&& rhs) {  // NOLINT
		TYPE_CHECK(T, S);
		if (this != &rhs) {
			this->Reset();
			this->val_ = rhs.val_;
			this->weakWrapper_ = rhs.weakWrapper_;
			rhs.val_ = JSC::JSValue();
			rhs.weakWrapper_ = nullptr;
		}
		return *this;
	}
	
	Global Pass() { return static_cast<Global&&>(*this); }  // NOLINT

	Global(const Global&) = delete;
	void operator=(const Global&) = delete;

private:
	template <class F> friend class ReturnValue;

	V8_INLINE T* operator*() const { return this->val_; }
};

template<class T>
class NonCopyablePersistentTraits {
public:
	typedef Persistent<T, NonCopyablePersistentTraits<T> > NonCopyablePersistent;
	static const bool kResetInDestructor = true; // jsc: Changed to true (like chakra)
	
	template<class S, class M>
	V8_INLINE static void Copy(const Persistent<S, M>& source, NonCopyablePersistent* dest) {
		Uncompilable<Object>();
	}

	template<class O> V8_INLINE static void Uncompilable() {
		TYPE_CHECK(O, Primitive);
	}
};


template<class T>
struct CopyablePersistentTraits {
	typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;
	static const bool kResetInDestructor = true;
	
	template<class S, class M>
	static V8_INLINE void Copy(const Persistent<S, M>& source, CopyablePersistent* dest) {
		// do nothing, just allow copy
	}
};

template <class T, class M>
class Persistent : public PersistentBase<T>
{
public:
	V8_INLINE Persistent() : PersistentBase<T>() { }

	template <class S>
	V8_INLINE Persistent(Isolate* isolate, Local<S> that)
		: PersistentBase<T>(that.val_) {
		TYPE_CHECK(T, S);
	}

	template <class S, class M2>
	V8_INLINE Persistent(Isolate* isolate, const Persistent<S, M2>& that)
		: PersistentBase<T>(that.val_) {
		TYPE_CHECK(T, S);
	}

	V8_INLINE Persistent(const Persistent& that) : PersistentBase<T>() {
		Copy(that);
	}
	template <class S, class M2>
	V8_INLINE Persistent(const Persistent<S, M2>& that) : PersistentBase<T>() {
		Copy(that);
	}
	V8_INLINE Persistent& operator=(const Persistent& that) { // NOLINT
		Copy(that);
		return *this;
	}
	template <class S, class M2>
	V8_INLINE Persistent& operator=(const Persistent<S, M2>& that) { // NOLINT
		Copy(that);
		return *this;
	}

	V8_INLINE ~Persistent() {
		if (M::kResetInDestructor) {
			this->Reset();
		}
	}

	template <class S>
	V8_INLINE static Persistent<T>& Cast(const Persistent<S>& that) {  // NOLINT
#ifdef V8_ENABLE_CHECKS
		// If we're going to perform the type check then we have to check
		// that the handle isn't empty before doing the checked cast.
		if (!that.IsEmpty()) T::Cast(*that);
#endif
		return reinterpret_cast<Persistent<T>&>(const_cast<Persistent<S>&>(that));
	}

	template <class S>
	V8_INLINE Persistent<S>& As() const {  // NOLINT
		return Persistent<S>::Cast(*this);
	}

private:
	template <class F> friend class ReturnValue;
	template <class F1, class F2> friend class Persistent;

	explicit V8_INLINE Persistent(T* that) : PersistentBase<T>(that) {}

	V8_INLINE T* operator*() const { return reinterpret_cast<T *>(const_cast<JSC::JSValue *>(&this->val_)); }
	
	template<class S, class M2>
	V8_INLINE void Copy(const Persistent<S, M2>& that);
};

typedef void(*MicrotaskCallback)(void* data);

class V8_EXPORT Isolate
{
public:
	struct CreateParams
	{
		ArrayBuffer::Allocator * array_buffer_allocator;
	};

	class V8_EXPORT Scope 
	{
	private:
		Isolate * const m_isolate;

	public:
		explicit Scope(Isolate* isolate) : m_isolate(isolate)
		{
			isolate->Enter();
		}

		~Scope() { m_isolate->Exit(); }

		// Prevent copying of Scope objects.
		Scope(const Scope&) = delete;
		Scope& operator=(const Scope&) = delete;
	};

	enum MessageErrorLevel
	{
		kMessageLog = (1 << 0),
		kMessageDebug = (1 << 1),
		kMessageInfo = (1 << 2),
		kMessageError = (1 << 3),
		kMessageWarning = (1 << 4),
		kMessageAll = kMessageLog | kMessageDebug | kMessageInfo | kMessageError |
		kMessageWarning,
	};

	static Isolate* New(const CreateParams& params);

	static Isolate* GetCurrent();

	void Dispose();

	typedef bool(*AbortOnUncaughtExceptionCallback)(Isolate*);
	void SetAbortOnUncaughtExceptionCallback(AbortOnUncaughtExceptionCallback callback);
	
	void Enter();

	void Exit();

	void SetData(uint32_t slot, void * data);
	
	void * GetData(uint32_t slot);

	static uint32_t GetNumberOfDataSlots();

	bool InContext();

	Local<Context> GetCurrentContext();

	Local<Context> GetEnteredContext();

	Local<Value> ThrowException(Local<Value> exception);

	typedef void(*GCCallback)(Isolate* isolate, GCType type,
		GCCallbackFlags flags);
	typedef void(*GCCallbackWithData)(Isolate* isolate, GCType type,
		GCCallbackFlags flags, void* data);

	void AddGCPrologueCallback(GCCallbackWithData callback, void* data = nullptr,
		GCType gc_type_filter = kGCTypeAll);
	void AddGCPrologueCallback(GCCallback callback,
		GCType gc_type_filter = kGCTypeAll);

	void RemoveGCPrologueCallback(GCCallbackWithData, void* data = nullptr);
	void RemoveGCPrologueCallback(GCCallback callback);

	void AddGCEpilogueCallback(GCCallbackWithData callback, void* data = nullptr,
		GCType gc_type_filter = kGCTypeAll);
	void AddGCEpilogueCallback(GCCallback callback,
		GCType gc_type_filter = kGCTypeAll);

	void RemoveGCEpilogueCallback(GCCallbackWithData callback, void* data = nullptr);
	void RemoveGCEpilogueCallback(GCCallback callback);

	int64_t AdjustAmountOfExternalAllocatedMemory(int64_t change_in_bytes);

	void GetHeapStatistics(HeapStatistics* heap_statistics);

	bool GetHeapSpaceStatistics(HeapSpaceStatistics* space_statistics, size_t index);

	size_t NumberOfHeapSpaces();

	HeapProfiler * GetHeapProfiler();

	V8_DEPRECATE_SOON("CpuProfiler should be created with CpuProfiler::New call.",
					  CpuProfiler * GetCpuProfiler());

	void SetPromiseHook(PromiseHook hook);

	void SetPromiseRejectCallback(PromiseRejectCallback callback);

	void RunMicrotasks();

	void EnqueueMicrotask(Local<Function> microtask);

	void EnqueueMicrotask(MicrotaskCallback microtask, void* data = NULL);

	void SetMicrotasksPolicy(MicrotasksPolicy policy);
	V8_DEPRECATE_SOON("Use SetMicrotasksPolicy",
					  void SetAutorunMicrotasks(bool autorun));

	void TerminateExecution();

	void CancelTerminateExecution();

	void RequestInterrupt(InterruptCallback callback, void* data);

	bool AddMessageListener(MessageCallback that, Local<Value> data = Local<Value>());

	void RemoveMessageListeners(MessageCallback that);

	void SetCaptureStackTraceForUncaughtExceptions(bool capture, 
												   int frame_limit = 10,
												   StackTrace::StackTraceOptions options = StackTrace::kOverview);

	void SetFatalErrorHandler(FatalErrorCallback that);

	void SetCounterFunction(CounterLookupCallback);

	void SetCreateHistogramFunction(CreateHistogramCallback);
	void SetAddHistogramSampleFunction(AddHistogramSampleCallback);

	bool IdleNotificationDeadline(double deadline_in_seconds);

	void LowMemoryNotification();

	int ContextDisposedNotification(bool dependant_context = true);
};


typedef bool (*EntropySource)(unsigned char* buffer, size_t length);

class V8_EXPORT V8
{
public:
	static const char* GetVersion();

	static bool Initialize();

	static void SetEntropySource(EntropySource source);

	static bool Dispose();

	static void SetFlagsFromString(const char * str, int length);

	static void SetFlagsFromCommandLine(int * argc,
										char ** argv,
										bool remove_flags);

	static void InitializePlatform(Platform * platform);

	static void ShutdownPlatform();

	static void FromJustIsNothing();
	static void ToLocalEmpty();
	static void InternalFieldOutOfBounds(int index);
};

template <class T>
class Maybe
{
private:
	bool has_value_;
	T value_;

public:
	V8_INLINE bool IsNothing() const { return !has_value_; }
	V8_INLINE bool IsJust() const { return has_value_; }

	V8_INLINE T ToChecked() const { return FromJust(); }

	// Will crash if the Maybe<> is nothing.
	V8_INLINE T FromJust() const
	{
		if (V8_UNLIKELY(!IsJust())) V8::FromJustIsNothing();
		return value_;
	}

	V8_INLINE T FromMaybe(const T& default_value) const
	{
		return has_value_ ? value_ : default_value;
	}

	V8_WARN_UNUSED_RESULT V8_INLINE bool To(T* out) const
	{
		if (V8_LIKELY(IsJust())) *out = value_;
		return IsJust();
	}

	V8_INLINE bool operator==(const Maybe& other) const
	{
		return (IsJust() == other.IsJust()) &&
			(!IsJust() || FromJust() == other.FromJust());
	}

	V8_INLINE bool operator!=(const Maybe& other) const
	{
		return !operator==(other);
	}

private:
	Maybe() : has_value_(false) {}
	explicit Maybe(const T& t) : has_value_(true), value_(t) {}

	template <class U> friend Maybe<U> Nothing();
	template <class U> friend Maybe<U> Just(const U& u);
};

template <class T>
inline Maybe<T> Nothing() {
	return Maybe<T>();
}

template <class T>
inline Maybe<T> Just(const T& t) {
	return Maybe<T>(t);
}

class V8_EXPORT AccessorSignature : public Data
{
public:
	static Local<AccessorSignature> New(
		Isolate* isolate,
		Local<FunctionTemplate> receiver = Local<FunctionTemplate>());
};


// Implementations

//
// Local<T> members
//
template <class T>
Local<T> Local<T>::New(T * that) 
{
	return Local<T>(*reinterpret_cast<JSC::JSValue *>(that));
}

template <class T>
Local<T> Local<T>::New(Isolate* isolate, Local<T> that)
{
	return Local<T>(that.val_);
}

template <class T>
Local<T> Local<T>::New(Isolate* isolate, const PersistentBase<T>& that)
{
	return Local<T>(that.val_);
}

template <class T>
Local<T> Local<T>::New(const JSC::JSValue& that)
{
	return Local<T>(that);
}

//
// MaybeLocal<T> members
//
template <class T>
Local<T> MaybeLocal<T>::ToLocalChecked() 
{
	if (V8_UNLIKELY(val_.isEmpty()))
	{
		V8::ToLocalEmpty();
	}
	return Local<T>(val_);
}

//
// Template members
//
void Template::Set(Isolate* isolate, const char* name, Local<Data> value)
{
	Set(String::NewFromUtf8(isolate, name, NewStringType::kInternalized).ToLocalChecked(), 
		value);
}

//
// FunctionCallbackInfo<T> members
//
template <class T>
FunctionCallbackInfo<T>::FunctionCallbackInfo(JSC::JSValue	 * arguments,
											  int			 argumentsCount,
											  Local<Object>	 thisValue,
											  Local<Object>	 holder,
											  Local<Value>   newTarget,
											  bool			 isConstructorCall,
											  Local<Value>	 data,
											  Isolate		 * isolate,
											  JSC::JSValue	 * returnValue) :
	arguments_(arguments),
	argumentsCount_(argumentsCount),
	this_(thisValue),
	data_(data),
	holder_(holder),
	newTarget_(newTarget),
	isConstructorCall_(isConstructorCall),
	isolate_(isolate),
	returnValue_(returnValue)
{
}

template <class T>
int FunctionCallbackInfo<T>::Length() const
{
	return argumentsCount_;
}

template <class T>
Local<Value> FunctionCallbackInfo<T>::operator[](int i) const
{
	if ((i < 0) || (argumentsCount_ <= i))
	{
		return Local<Value>(Undefined(GetIsolate()).val_);
	}

	return Local<Value>(arguments_[i]);
}

template <class T>
Local<Object> FunctionCallbackInfo<T>::This() const
{
	return this_;
}

template <class T>
Local<Value> FunctionCallbackInfo<T>::NewTarget() const
{
	return newTarget_;
}

template <class T>
Local<Object> FunctionCallbackInfo<T>::Holder() const
{
	return holder_;
}

template <class T>
bool FunctionCallbackInfo<T>::IsConstructCall() const
{
	return isConstructorCall_;
}

template <class T>
Local<Value> FunctionCallbackInfo<T>::Data() const
{
	return data_;
}

template <class T>
Isolate* FunctionCallbackInfo<T>::GetIsolate() const
{
	return isolate_;
}

template <class T>
ReturnValue<T> FunctionCallbackInfo<T>::GetReturnValue() const
{
	return ReturnValue<T>(returnValue_);
}

//
// PropertyCallbackInfo<T> members
//
template <class T>
PropertyCallbackInfo<T>::PropertyCallbackInfo(Local<Object>	 thisValue,
											  Local<Object>	 holder,
											  Local<Value>	 data,
											  Isolate		 * isolate,
											  JSC::JSValue	 * returnValue,
											  bool			 shouldThrowOnError) :
	this_(thisValue),
	data_(data),
	holder_(holder),
	isolate_(isolate),
	returnValue_(returnValue),
	shouldThrowOnError_(shouldThrowOnError)
{

}


template <class T>
Isolate* PropertyCallbackInfo<T>::GetIsolate() const
{
	return isolate_;
}


template <class T>
Local<Value> PropertyCallbackInfo<T>::Data() const
{
	return data_;
}

template <class T>
Local<Object> PropertyCallbackInfo<T>::This() const
{
	return this_;
}

template <class T>
Local<Object> PropertyCallbackInfo<T>::Holder() const
{
	return holder_;
}

template <class T>
ReturnValue<T> PropertyCallbackInfo<T>::GetReturnValue() const
{
	return ReturnValue<T>(returnValue_);
}

template <class T>
bool PropertyCallbackInfo<T>::ShouldThrowOnError() const
{
	return shouldThrowOnError_;
}

//
// ReturnValue<T> members
//
template <class T>
template <class S>
void ReturnValue<T>::Set(const Persistent<S>& handle)
{
	*value_ = handle.val_;
}

template <class T>
template <typename S>
void ReturnValue<T>::Set(const Local<S> handle)
{
	*value_ = handle.val_;
}

template <class T>
void ReturnValue<T>::Set(bool value)
{
	Set(Boolean::New(Isolate::GetCurrent(), value));
}

template <class T>
void ReturnValue<T>::Set(double i)
{
	Set(Number::New(Isolate::GetCurrent(), i));
}

template <class T>
void ReturnValue<T>::Set(int32_t i)
{
	Set(Int32::New(Isolate::GetCurrent(), i));
}

template <class T>
void ReturnValue<T>::Set(uint32_t i)
{
	Set(Uint32::NewFromUnsigned(Isolate::GetCurrent(), i));
}

template <class T>
void ReturnValue<T>::SetNull()
{
	// jscshim: No need for an isolate
	Set(Null(nullptr));
}

template <class T>
void ReturnValue<T>::SetUndefined()
{
	// jscshim: No need for an isolate
	Set(Undefined(nullptr));
}

template <class T>
void ReturnValue<T>::SetEmptyString()
{
	Set(String::Empty(Isolate::GetCurrent()));
}

//
// Persistent<T, M> members
//
template <class T, class M>
template <class S, class M2>
void Persistent<T, M>::Copy(const Persistent<S, M2>& that) {
	TYPE_CHECK(T, S);
	this->Reset();
	if (that.IsEmpty())
	{
		return;
	}

	this->val_ = that.val_;
	this->eakWrapper_ = that.weakWrapper_;
	if (!this->IsEmpty() && !this->IsWeak()) {
		jscshim::Heap::ProtectValue(this->val_);
	}
	
	M::Copy(that, this);
}

//
// PersistentBase<T> members
//
template <class T>
void PersistentBase<T>::Reset()
{
	if (this->IsEmpty())
	{
		return;
	}

	if (weakWrapper_)
	{
		delete weakWrapper_;
		weakWrapper_ = nullptr;
	}
	else
	{
		jscshim::Heap::UnprotectValue(val_);
	}

	val_ = JSC::JSValue();
}

template <class T>
template <class S>
void PersistentBase<T>::Reset(Isolate* isolate, const Local<S>& other)
{
	TYPE_CHECK(T, S);
	
	Reset();
	if (other.IsEmpty())
	{
		return;
	}

	this->val_ = other.val_;
	jscshim::Heap::ProtectValue(this->val_);
}

template <class T>
template <typename P>
void PersistentBase<T>::SetWeak(P* parameter,
								typename WeakCallbackInfo<P>::Callback callback,
								WeakCallbackType type)
{
	if (this->IsEmpty())
	{
		return;
	}

	v8::Isolate * isolate = v8::Isolate::GetCurrent();

	bool wasStrong = !IsWeak();
	weakWrapper_ = new jscshim::WeakWrapper(isolate,
											val_,
											type, 
											reinterpret_cast<typename WeakCallbackInfo<void>::Callback>(callback), 
											reinterpret_cast<void *>(parameter));

	if (wasStrong)
	{
		jscshim::Heap::UnprotectValue(val_);
	}
}

template <class T>
template<typename P>
P* PersistentBase<T>::ClearWeak()
{
	if (!this->IsWeak())
	{
		return nullptr;
	}

	P * paramter = weakWrapper_->CallbackParameter();
	delete this->weakWrapper_;
	this->weakWrapper_ = nullptr;

	jscshim::Heap::ProtectValue(this->val_);
	
	return paramter;
}

template <class T>
void PersistentBase<T>::MarkIndependent()
{
	// TODO: IMPLEMENT?
}

template <class T>
bool PersistentBase<T>::IsNearDeath() const
{
	// In node, it seems that it's only used by ObjectWrap, which expects this to be true
	return true;
}

template <class T>
bool PersistentBase<T>::IsWeak() const
{
	return nullptr != this->weakWrapper_;
}

template <class T>
void PersistentBase<T>::SetWrapperClassId(uint16_t class_id)
{
	// TODO: IMPLEMENT
}

//
// WeakCallbackInfo<T> members
//
template <class T>
void* WeakCallbackInfo<T>::GetInternalField(int index) const
{
#ifdef V8_ENABLE_CHECKS
	if (index < 0 || index >= kEmbedderFieldsInWeakCallback) {
		V8::InternalFieldOutOfBounds(index);
	}
#endif
	return embedder_fields_[index];
}

//
// Cast Functions
//
External * External::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<External*>(value);
}

Map* Map::Cast(v8::Value* value) {
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Map*>(value);
}

Set* Set::Cast(v8::Value* value) {
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Set*>(value);
}

Promise* Promise::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Promise*>(value);
}

Promise::Resolver* Promise::Resolver::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Promise::Resolver*>(value);
}

Proxy* Proxy::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Proxy*>(value);
}

template <class T>
Value* Value::Cast(T* value)
{
	return static_cast<Value*>(value);
}

Date* Date::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Date*>(value);
}

StringObject* StringObject::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<StringObject*>(value);
}

SymbolObject* SymbolObject::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<SymbolObject*>(value);
}

RegExp* RegExp::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<RegExp*>(value);
}

NumberObject* NumberObject::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<NumberObject*>(value);
}

BooleanObject* BooleanObject::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<BooleanObject*>(value);
}

Object* Object::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Object*>(value);
}

Function* Function::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Function*>(value);
}

String* String::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<String*>(value);
}

Symbol* Symbol::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Symbol*>(value);
}

Array* Array::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Array*>(value);
}

ArrayBuffer* ArrayBuffer::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<ArrayBuffer*>(value);
}

ArrayBufferView* ArrayBufferView::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<ArrayBufferView*>(value);
}

DataView* DataView::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<DataView*>(value);
}

SharedArrayBuffer* SharedArrayBuffer::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<SharedArrayBuffer*>(value);
}

TypedArray* TypedArray::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<TypedArray*>(value);
}

Uint8Array* Uint8Array::Cast(Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Uint8Array*>(value);
}

Uint8ClampedArray* Uint8ClampedArray::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Uint8ClampedArray*>(value);
}

Int8Array* Int8Array::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Int8Array*>(value);
}

Uint16Array* Uint16Array::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Uint16Array*>(value);
}

Int16Array* Int16Array::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Int16Array*>(value);
}

Int32Array* Int32Array::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Int32Array*>(value);
}

Uint32Array* Uint32Array::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Uint32Array*>(value);
}

Float32Array* Float32Array::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Float32Array*>(value);
}

Float64Array* Float64Array::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Float64Array*>(value);
}

Boolean* Boolean::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Boolean*>(value);
}

Name* Name::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Name*>(value);
}

Number* Number::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Number*>(value);
}

Integer* Integer::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Integer*>(value);
}

Int32* Int32::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Int32*>(value);
}

Uint32* Uint32::Cast(v8::Value* value)
{
#ifdef V8_ENABLE_CHECKS
	CheckCast(value);
#endif
	return static_cast<Uint32*>(value);
}

//
// Boolean members
//
Local<Boolean> Boolean::New(Isolate* isolate, bool value)
{
	return value ? True(isolate) : False(isolate);
}

//
// Value members
//
V8_INLINE Local<Boolean> Value::ToBoolean(Isolate* isolate) const
{
	return ToBoolean(isolate->GetCurrentContext()).FromMaybe(Local<Boolean>());
}

V8_INLINE Local<Number> Value::ToNumber(Isolate* isolate) const
{
	return ToNumber(isolate->GetCurrentContext()).FromMaybe(Local<Number>());
}

V8_INLINE Local<String> Value::ToString(Isolate* isolate) const
{
	return ToString(isolate->GetCurrentContext()).FromMaybe(Local<String>());
}

V8_INLINE Local<String> Value::ToDetailString(Isolate* isolate) const
{
	// TODO: Follow v8's ToDetailString
	return ToString(isolate->GetCurrentContext()).FromMaybe(Local<String>());
}

V8_INLINE Local<Object> Value::ToObject(Isolate* isolate) const
{
	return ToObject(isolate->GetCurrentContext()).FromMaybe(Local<Object>());
}

V8_INLINE Local<Integer> Value::ToInteger(Isolate* isolate) const
{
	return ToInteger(isolate->GetCurrentContext()).FromMaybe(Local<Integer>());
}

V8_INLINE Local<Uint32> Value::ToUint32(Isolate* isolate) const
{
	return ToUint32(isolate->GetCurrentContext()).FromMaybe(Local<Uint32>());
}

V8_INLINE Local<Int32> Value::ToInt32(Isolate* isolate) const
{
	return ToInt32(isolate->GetCurrentContext()).FromMaybe(Local<Int32>());
}

V8_INLINE bool Value::BooleanValue() const
{
	return BooleanValue(Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(false);
}

V8_INLINE int64_t Value::IntegerValue() const
{
	return IntegerValue(Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(0);
}

V8_INLINE int32_t Value::Int32Value() const
{
	return Int32Value(Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(0);
}

V8_INLINE uint32_t Value::Uint32Value() const
{
	return Uint32Value(Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(0);
}

V8_INLINE Local<String> Value::ToString() const
{
	return ToString(Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(Local<String>());
}

//
// ScriptOrigin members
//
ScriptOrigin::ScriptOrigin(Local<Value> resource_name,
						   Local<Integer> resource_line_offset,
						   Local<Integer> resource_column_offset,
						   Local<Boolean> resource_is_shared_cross_origin,
						   Local<Integer> script_id,
						   Local<Value> source_map_url,
						   Local<Boolean> resource_is_opaque,
						   Local<Boolean> is_wasm, Local<Boolean> is_module)
	: resource_name_(resource_name),
	  resource_line_offset_(resource_line_offset),
	  resource_column_offset_(resource_column_offset),
	  options_(!resource_is_shared_cross_origin.IsEmpty() && resource_is_shared_cross_origin->IsTrue(),
			   !resource_is_opaque.IsEmpty() && resource_is_opaque->IsTrue(),
			   !is_wasm.IsEmpty() && is_wasm->IsTrue(),
			   !is_module.IsEmpty() && is_module->IsTrue()),
	script_id_(script_id),
	source_map_url_(source_map_url) {}

//
// ScriptCompiler::Source members
//
V8_INLINE ScriptCompiler::Source::Source(Local<String> string, const ScriptOrigin& origin, CachedData* data) :
	source_string(string),
	resource_name(origin.ResourceName()),
	resource_line_offset(origin.ResourceLineOffset()),
	resource_column_offset(origin.ResourceColumnOffset()),
	source_map_url(origin.SourceMapUrl())
{
}

V8_INLINE ScriptCompiler::Source::Source(Local<String> string, CachedData* data) :
	source_string(string)
{
}

//
// Object members
//
V8_INLINE int Object::InternalFieldCount(const PersistentBase<Object>& object)
{
	// (jscshim) TODO: Avoid creating a temp Local?
	return object.Get(Isolate::GetCurrent())->InternalFieldCount();
}

V8_INLINE void* Object::GetAlignedPointerFromInternalField(const PersistentBase<Object>& object, int index)
{
	// (jscshim) TODO: Avoid creating a temp Local?
	return object.Get(Isolate::GetCurrent())->GetAlignedPointerFromInternalField(index);
}

}
